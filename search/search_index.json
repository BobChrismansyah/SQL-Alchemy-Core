{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Tugas Teknologi Basis Data \u00b6 Dokumentasi ini dibuat dari hasil translate dari website https://www.tutorialspoint.com/sqlalchemy/index.htm Silahkan klik website tersebut untuk melihat dokumentasi aslinya. Terima Kasih \u00b6","title":"Docs"},{"location":"#tugas-teknologi-basis-data","text":"Dokumentasi ini dibuat dari hasil translate dari website https://www.tutorialspoint.com/sqlalchemy/index.htm Silahkan klik website tersebut untuk melihat dokumentasi aslinya.","title":"Tugas Teknologi Basis Data"},{"location":"#terima-kasih","text":"","title":"Terima Kasih"},{"location":"about/","text":"","title":"About"},{"location":"docs/Connecting-to-Database/","text":"Menghubungkan ke database \u00b6 Pada materi sebelumnya, kita telah membahas tentang bahasa ekspresi di SQLAlchemy. Sekarang mari kita lanjutkan ke langkah-langkah yang dibutuhkan dalam menghubungkan ke database. Kelas mesin menghubungkan Pool dan Dialect bersama -sama untuk menyediakan sumber konektivitas dan perilaku database. Objek kelas Engine dibuat instance-nya menggunakan fungsi create_engine(). Fungsi create_engine() mengambil database sebagai satu argumen. Basis data tidak perlu didefinisikan di mana pun. Formulir pemanggilan standar harus mengirim URL sebagai argumen posisi pertama, biasanya berupa string yang menunjukkan dialek database dan argumen koneksi. Menggunakan kode yang diberikan di bawah ini, kita dapat membuat database. >>> from sqlalchemy import create_engine >>> engine = create_engine ( 'sqlite:///college.db' , echo = True ) Untuk database MySQL , gunakan perintah di bawah ini engine = create_engine ( \"mysql://user:pwd@localhost/college\" , echo = True ) Untuk secara khusus menyebutkan DB-API yang akan digunakan untuk koneksi, string URL berbentuk sebagai berikut dialect [ + driver ]: // user : password @ host / dbname Misalnya, jika Anda menggunakan driver PyMySQL dengan MySQL , gunakan perintah berikut mysql + pymysql : //< username > : < password >@< host >/< dbname > Echo Flasgs adalah shortcut untuk menyiapkan logging SQLAlchemy, yang dilakukan melalui modul logging standar Python. Pada bab selanjutnya, kita akan mempelajari semua SQL yang dihasilkan. Untuk menyembunyikan output verbose, setel atribut echo ke None. Argumen lain untuk fungsi create_engine() mungkin khusus untuk dialek. No Metode & Deskripsi 1 connect() Return koneksi object 2 execute() Mengeksekusi konstruksi pernyataan SQL 3 begin() Mengembalikan konteks manager yang mengirimkan koneksi dengan transaksi yang dibuat 4 dispose() Membuang kumpulan koneksi yang digunakan oleh Engine 5 driver() Nama driver yang digunakan oleh Engine 6 table_name() Mengembalikan daftar semua nama tabel yang tersedia di database 7 transaction() Mengeksekusi fungsi yang diberikan dalam batas transaksi","title":"Connecting to Database"},{"location":"docs/Connecting-to-Database/#menghubungkan-ke-database","text":"Pada materi sebelumnya, kita telah membahas tentang bahasa ekspresi di SQLAlchemy. Sekarang mari kita lanjutkan ke langkah-langkah yang dibutuhkan dalam menghubungkan ke database. Kelas mesin menghubungkan Pool dan Dialect bersama -sama untuk menyediakan sumber konektivitas dan perilaku database. Objek kelas Engine dibuat instance-nya menggunakan fungsi create_engine(). Fungsi create_engine() mengambil database sebagai satu argumen. Basis data tidak perlu didefinisikan di mana pun. Formulir pemanggilan standar harus mengirim URL sebagai argumen posisi pertama, biasanya berupa string yang menunjukkan dialek database dan argumen koneksi. Menggunakan kode yang diberikan di bawah ini, kita dapat membuat database. >>> from sqlalchemy import create_engine >>> engine = create_engine ( 'sqlite:///college.db' , echo = True ) Untuk database MySQL , gunakan perintah di bawah ini engine = create_engine ( \"mysql://user:pwd@localhost/college\" , echo = True ) Untuk secara khusus menyebutkan DB-API yang akan digunakan untuk koneksi, string URL berbentuk sebagai berikut dialect [ + driver ]: // user : password @ host / dbname Misalnya, jika Anda menggunakan driver PyMySQL dengan MySQL , gunakan perintah berikut mysql + pymysql : //< username > : < password >@< host >/< dbname > Echo Flasgs adalah shortcut untuk menyiapkan logging SQLAlchemy, yang dilakukan melalui modul logging standar Python. Pada bab selanjutnya, kita akan mempelajari semua SQL yang dihasilkan. Untuk menyembunyikan output verbose, setel atribut echo ke None. Argumen lain untuk fungsi create_engine() mungkin khusus untuk dialek. No Metode & Deskripsi 1 connect() Return koneksi object 2 execute() Mengeksekusi konstruksi pernyataan SQL 3 begin() Mengembalikan konteks manager yang mengirimkan koneksi dengan transaksi yang dibuat 4 dispose() Membuang kumpulan koneksi yang digunakan oleh Engine 5 driver() Nama driver yang digunakan oleh Engine 6 table_name() Mengembalikan daftar semua nama tabel yang tersedia di database 7 transaction() Mengeksekusi fungsi yang diberikan dalam batas transaksi","title":"Menghubungkan ke database"},{"location":"docs/Creating-Table/","text":"Membuat Tabel \u00b6 SQL menyusun ekspresinya terhadap kolom tabel. Objek SQLAlchemy Column mewakili kolom dalam tabel database yang pada gilirannya diwakili oleh Tableobject. Metadata berisi definisi tabel dan objek terkait seperti indeks, tampilan, triggers, dll. Karena objek kelas MetaData dari SQLAlchemy Metadata adalah kumpulan objek Tabel dan konstruksi skema yang terkait. Ini menampung kumpulan objek Tabel serta pengikatan opsional ke Mesin atau Koneksi. from sqlalchemy import MetaData meta = MetaData () Konstruktor kelas MetaData dapat memiliki parameter bind dan skema yang secara default adalah None. Selanjutnya, kita mendefinisikan tabel kita semua di dalam katalog metadata di atas, menggunakan Table construct , yang menyerupai pernyataan SQL CREATE TABLE biasa. Objek kelas Tabel mewakili tabel yang sesuai dalam database. Konstruktor mengambil parameter berikut Nama Nama tabel metadata Objek MetaData yang akan mengandung tabel ini Kolom Satu atau lebih objek kelas kolom Objek kolom mewakili kolom dalam tabel database. Konstruktor mengambil nama, tipe, dan parameter lain seperti primary_key, autoincrement, dan batasan lainnya. SQLAlchemy mencocokkan data Python dengan tipe data kolom generik terbaik yang ditentukan di dalamnya. Beberapa tipe data umum adalah: BigInteger Boolean Date DateTime Float Integer Numeric SmallInteger Sting Text Time Untuk membuat tabel siswa di database perguruan tinggi, gunakan potongan berikut: from sqlalchemy import Table , Column , Integer , String , MetaData meta = MetaData () students = Table ( 'students' , meta , Column ( 'id' , Integer , primary_key = True ), Column ( 'name' , String ), Column ( 'lastname' , String ), ) Fungsi create_all() menggunakan objek mesin untuk membuat semua objek tabel yang ditentukan dan menyimpan informasi dalam metadata. meta . create_all ( engine ) Kode lengkap diberikan di bawah ini yang akan membuat database SQLite college.db dengan tabel siswa di dalamnya. Karena echo atribut dari fungsi create_engine() disetel ke True, konsol akan menampilkan kueri SQL aktual untuk pembuatan tabel sebagai berikut: college.db akan dibuat di direktori kerja saat ini. Untuk memeriksa apakah tabel siswa sudah dibuat, Anda dapat membuka database menggunakan alat GUI SQLite seperti SQLiteStudio","title":"Creating Table"},{"location":"docs/Creating-Table/#membuat-tabel","text":"SQL menyusun ekspresinya terhadap kolom tabel. Objek SQLAlchemy Column mewakili kolom dalam tabel database yang pada gilirannya diwakili oleh Tableobject. Metadata berisi definisi tabel dan objek terkait seperti indeks, tampilan, triggers, dll. Karena objek kelas MetaData dari SQLAlchemy Metadata adalah kumpulan objek Tabel dan konstruksi skema yang terkait. Ini menampung kumpulan objek Tabel serta pengikatan opsional ke Mesin atau Koneksi. from sqlalchemy import MetaData meta = MetaData () Konstruktor kelas MetaData dapat memiliki parameter bind dan skema yang secara default adalah None. Selanjutnya, kita mendefinisikan tabel kita semua di dalam katalog metadata di atas, menggunakan Table construct , yang menyerupai pernyataan SQL CREATE TABLE biasa. Objek kelas Tabel mewakili tabel yang sesuai dalam database. Konstruktor mengambil parameter berikut Nama Nama tabel metadata Objek MetaData yang akan mengandung tabel ini Kolom Satu atau lebih objek kelas kolom Objek kolom mewakili kolom dalam tabel database. Konstruktor mengambil nama, tipe, dan parameter lain seperti primary_key, autoincrement, dan batasan lainnya. SQLAlchemy mencocokkan data Python dengan tipe data kolom generik terbaik yang ditentukan di dalamnya. Beberapa tipe data umum adalah: BigInteger Boolean Date DateTime Float Integer Numeric SmallInteger Sting Text Time Untuk membuat tabel siswa di database perguruan tinggi, gunakan potongan berikut: from sqlalchemy import Table , Column , Integer , String , MetaData meta = MetaData () students = Table ( 'students' , meta , Column ( 'id' , Integer , primary_key = True ), Column ( 'name' , String ), Column ( 'lastname' , String ), ) Fungsi create_all() menggunakan objek mesin untuk membuat semua objek tabel yang ditentukan dan menyimpan informasi dalam metadata. meta . create_all ( engine ) Kode lengkap diberikan di bawah ini yang akan membuat database SQLite college.db dengan tabel siswa di dalamnya. Karena echo atribut dari fungsi create_engine() disetel ke True, konsol akan menampilkan kueri SQL aktual untuk pembuatan tabel sebagai berikut: college.db akan dibuat di direktori kerja saat ini. Untuk memeriksa apakah tabel siswa sudah dibuat, Anda dapat membuka database menggunakan alat GUI SQLite seperti SQLiteStudio","title":"Membuat Tabel"},{"location":"docs/Delete-Expression/","text":"Menggunakan Delete \u00b6 Di bab sebelumnya, kita telah memahami apa yang dilakukan ekspresi Pembaruan . Ekspresi selanjutnya yang akan kita pelajari adalah Delete. Operasi hapus dapat dicapai dengan menjalankan metode delete() pada objek tabel target seperti yang diberikan dalam pernyataan berikut stmt = students . delete () Dalam kasus tabel siswa, baris kode di atas membuat ekspresi SQL sebagai berikut 'DELETE FROM students' Namun, ini akan menghapus semua baris dalam tabel siswa. Biasanya kueri DELETE dikaitkan dengan ekspresi logis yang ditentukan oleh klausa WHERE. Pernyataan berikut menunjukkan di mana parameter stmt = students . delete () . where ( students . c . id > 2 ) Ekspresi SQL yang dihasilkan akan memiliki parameter terikat yang akan diganti saat runtime saat pernyataan dijalankan. 'DELETE FROM students WHERE students.id > :id_1' Contoh kode berikut akan menghapus baris-baris dari tabel siswa yang memiliki nama belakang sebagai 'Lagi' from sqlalchemy.sql.expression import update from sqlalchemy import create_engine , MetaData , Table , Column , Integer , String engine = create_engine ( 'sqlite:///college.db' , echo = True ) meta = MetaData () students = Table ( 'students' , meta , Column ( 'id' , Integer , primary_key = True ), Column ( 'name' , String ), Column ( 'lastname' , String ), ) conn = engine . connect () stmt = students . delete () . where ( students . c . lastname == 'Khanna' ) conn . execute ( stmt ) s = students . select () conn . execute ( s ) . fetchall () Hasilnya (1, 'Ahmad', 'Haidir') (2, 'Bob', 'Chrismansayah') (3, 'Ariandini', 'Aulia') (4, 'Bob', 'Langau') (5, 'Aiandini', 'Dini') (6, 'Haidir', 'Ahmed')","title":"Index"},{"location":"docs/Delete-Expression/#menggunakan-delete","text":"Di bab sebelumnya, kita telah memahami apa yang dilakukan ekspresi Pembaruan . Ekspresi selanjutnya yang akan kita pelajari adalah Delete. Operasi hapus dapat dicapai dengan menjalankan metode delete() pada objek tabel target seperti yang diberikan dalam pernyataan berikut stmt = students . delete () Dalam kasus tabel siswa, baris kode di atas membuat ekspresi SQL sebagai berikut 'DELETE FROM students' Namun, ini akan menghapus semua baris dalam tabel siswa. Biasanya kueri DELETE dikaitkan dengan ekspresi logis yang ditentukan oleh klausa WHERE. Pernyataan berikut menunjukkan di mana parameter stmt = students . delete () . where ( students . c . id > 2 ) Ekspresi SQL yang dihasilkan akan memiliki parameter terikat yang akan diganti saat runtime saat pernyataan dijalankan. 'DELETE FROM students WHERE students.id > :id_1' Contoh kode berikut akan menghapus baris-baris dari tabel siswa yang memiliki nama belakang sebagai 'Lagi' from sqlalchemy.sql.expression import update from sqlalchemy import create_engine , MetaData , Table , Column , Integer , String engine = create_engine ( 'sqlite:///college.db' , echo = True ) meta = MetaData () students = Table ( 'students' , meta , Column ( 'id' , Integer , primary_key = True ), Column ( 'name' , String ), Column ( 'lastname' , String ), ) conn = engine . connect () stmt = students . delete () . where ( students . c . lastname == 'Khanna' ) conn . execute ( stmt ) s = students . select () conn . execute ( s ) . fetchall () Hasilnya (1, 'Ahmad', 'Haidir') (2, 'Bob', 'Chrismansayah') (3, 'Ariandini', 'Aulia') (4, 'Bob', 'Langau') (5, 'Aiandini', 'Dini') (6, 'Haidir', 'Ahmed')","title":"Menggunakan Delete"},{"location":"docs/Executing-Expression/","text":"Mengeksekusi \u00b6 Untuk mengeksekusi ekspresi SQL yang dihasilkan, kita harus mendapatkan objek koneksi yang mewakili sumber daya koneksi DBAPI yang diperiksa secara aktif dan kemudian memberi makan objek ekspresi seperti yang ditunjukkan pada kode di bawah ini. conn = engine . connect () Objek insert() berikut dapat digunakan untuk metode execution() ins = students . insert () . values ( name = 'Bob' , lastname = 'Chrismansyah' ) result = conn . execute ( ins ) Konsol menunjukkan hasil eksekusi ekspresi SQL seperti di bawah ini INSERT INTO students ( name , lastname ) VALUES ( ? , ? ) ( 'Bob' , 'Chrismansyah' ) COMMIT Berikut ini adalah keseluruhan cuplikan yang menunjukkan eksekusi query INSERT menggunakan teknik inti SQLAlchemy from sqlalchemy import create_engine , MetaData , Table , Column , Integer , String engine = create_engine ( 'sqlite:///college.db' , echo = True ) meta = MetaData () students = Table ( 'students' , meta , Column ( 'id' , Integer , primary_key = True ), Column ( 'name' , String ), Column ( 'lastname' , String ), ) ins = students . insert () # ins = students.insert().values(name = 'Bob', lastname = 'Chrismansayah') ins = students . insert () . values ( name = 'Ariandini' , lastname = 'Aulia' ) # ins = students.insert().values(name = 'Haidir', lastname = 'Haidir') # insert data dieksekusi hanya satu per satu, tidak bisa 3 sekaligus result = conn . execute ( ins ) Hasilnya dapat diverifikasi dengan membuka database menggunakan SQLite Studio seperti yang ditunjukkan pada tangkapan layar di bawah ini Variabel hasil dikenal sebagai objek ResultProxy . Ini analog dengan objek kursor DBAPI. Kami dapat memperoleh informasi tentang nilai kunci utama yang dihasilkan dari pernyataan kami menggunakan ResultProxy.inserted_primary_key seperti yang ditunjukkan di bawah ini result . inserted_primary_key [ 1 ] Untuk mengeluarkan banyak sisipan menggunakan metode execution many() DBAPI, kita dapat mengirimkan daftar kamus yang masing-masing berisi kumpulan parameter yang berbeda untuk disisipkan. conn . execute ( students . insert (), [ { 'name' : 'Bob' , 'lastname' : 'Langau' }, { 'name' : 'Aiandini' , 'lastname' : 'Dini' }, { 'name' : 'Haidir' , 'lastname' : 'Ahmed' }, { 'name' : 'Masuk' , 'lastname' : 'Saja' }, ])","title":"Executing Language"},{"location":"docs/Executing-Expression/#mengeksekusi","text":"Untuk mengeksekusi ekspresi SQL yang dihasilkan, kita harus mendapatkan objek koneksi yang mewakili sumber daya koneksi DBAPI yang diperiksa secara aktif dan kemudian memberi makan objek ekspresi seperti yang ditunjukkan pada kode di bawah ini. conn = engine . connect () Objek insert() berikut dapat digunakan untuk metode execution() ins = students . insert () . values ( name = 'Bob' , lastname = 'Chrismansyah' ) result = conn . execute ( ins ) Konsol menunjukkan hasil eksekusi ekspresi SQL seperti di bawah ini INSERT INTO students ( name , lastname ) VALUES ( ? , ? ) ( 'Bob' , 'Chrismansyah' ) COMMIT Berikut ini adalah keseluruhan cuplikan yang menunjukkan eksekusi query INSERT menggunakan teknik inti SQLAlchemy from sqlalchemy import create_engine , MetaData , Table , Column , Integer , String engine = create_engine ( 'sqlite:///college.db' , echo = True ) meta = MetaData () students = Table ( 'students' , meta , Column ( 'id' , Integer , primary_key = True ), Column ( 'name' , String ), Column ( 'lastname' , String ), ) ins = students . insert () # ins = students.insert().values(name = 'Bob', lastname = 'Chrismansayah') ins = students . insert () . values ( name = 'Ariandini' , lastname = 'Aulia' ) # ins = students.insert().values(name = 'Haidir', lastname = 'Haidir') # insert data dieksekusi hanya satu per satu, tidak bisa 3 sekaligus result = conn . execute ( ins ) Hasilnya dapat diverifikasi dengan membuka database menggunakan SQLite Studio seperti yang ditunjukkan pada tangkapan layar di bawah ini Variabel hasil dikenal sebagai objek ResultProxy . Ini analog dengan objek kursor DBAPI. Kami dapat memperoleh informasi tentang nilai kunci utama yang dihasilkan dari pernyataan kami menggunakan ResultProxy.inserted_primary_key seperti yang ditunjukkan di bawah ini result . inserted_primary_key [ 1 ] Untuk mengeluarkan banyak sisipan menggunakan metode execution many() DBAPI, kita dapat mengirimkan daftar kamus yang masing-masing berisi kumpulan parameter yang berbeda untuk disisipkan. conn . execute ( students . insert (), [ { 'name' : 'Bob' , 'lastname' : 'Langau' }, { 'name' : 'Aiandini' , 'lastname' : 'Dini' }, { 'name' : 'Haidir' , 'lastname' : 'Ahmed' }, { 'name' : 'Masuk' , 'lastname' : 'Saja' }, ])","title":"Mengeksekusi"},{"location":"docs/Expression-Language/","text":"Expression Language \u00b6 Inti SQLAlchemy mencakup mesin rendering SQL, integrasi DBAPI, integrasi transaksi , dan layanan deskripsi skema . Inti SQLAlchemy menggunakan SQL Expression Language yang menyediakan paradigma penggunaan yang berpusat pada skema sedangkan SQLAlchemy ORM adalah mode penggunaan yang berpusat pada domain . Bahasa Ekspresi SQL menyajikan sistem yang merepresentasikan struktur dan ekspresi basis data relasional menggunakan konstruksi Python. Ini menyajikan sistem yang mewakili konstruksi primitif dari basis data relasional secara langsung tanpa pendapat, yang berbeda dengan ORM yang menyajikan pola penggunaan tingkat tinggi dan abstrak, yang dengan sendirinya merupakan contoh penggunaan terapan dari Bahasa Ekspresi. Bahasa Ekspresi adalah salah satu komponen inti dari SQLAlchemy. Ini memungkinkan pemrogram untuk menentukan pernyataan SQL dalam kode Python dan menggunakannya secara langsung dalam kueri yang lebih kompleks. Bahasa ekspresi tidak bergantung pada backend dan secara komprehensif mencakup setiap aspek SQL mentah. Ini lebih dekat ke SQL mentah daripada komponen lain di SQLAlchemy. Bahasa Ekspresi mewakili konstruksi primitif dari basis data relasional secara langsung. Karena ORM didasarkan pada bahasa Expression, aplikasi database Python yang khas mungkin memiliki penggunaan keduanya yang tumpang tindih. Aplikasi dapat menggunakan bahasa ekspresi saja, meskipun harus menentukan sistemnya sendiri untuk menerjemahkan konsep aplikasi ke dalam kueri basis data individual. Pernyataan bahasa Ekspresi akan diterjemahkan ke dalam kueri SQL mentah yang sesuai oleh mesin SQLAlchemy. Sekarang kita akan mempelajari cara membuat mesin dan menjalankan berbagai kueri SQL dengan bantuannya.","title":"Expression Language"},{"location":"docs/Expression-Language/#expression-language","text":"Inti SQLAlchemy mencakup mesin rendering SQL, integrasi DBAPI, integrasi transaksi , dan layanan deskripsi skema . Inti SQLAlchemy menggunakan SQL Expression Language yang menyediakan paradigma penggunaan yang berpusat pada skema sedangkan SQLAlchemy ORM adalah mode penggunaan yang berpusat pada domain . Bahasa Ekspresi SQL menyajikan sistem yang merepresentasikan struktur dan ekspresi basis data relasional menggunakan konstruksi Python. Ini menyajikan sistem yang mewakili konstruksi primitif dari basis data relasional secara langsung tanpa pendapat, yang berbeda dengan ORM yang menyajikan pola penggunaan tingkat tinggi dan abstrak, yang dengan sendirinya merupakan contoh penggunaan terapan dari Bahasa Ekspresi. Bahasa Ekspresi adalah salah satu komponen inti dari SQLAlchemy. Ini memungkinkan pemrogram untuk menentukan pernyataan SQL dalam kode Python dan menggunakannya secara langsung dalam kueri yang lebih kompleks. Bahasa ekspresi tidak bergantung pada backend dan secara komprehensif mencakup setiap aspek SQL mentah. Ini lebih dekat ke SQL mentah daripada komponen lain di SQLAlchemy. Bahasa Ekspresi mewakili konstruksi primitif dari basis data relasional secara langsung. Karena ORM didasarkan pada bahasa Expression, aplikasi database Python yang khas mungkin memiliki penggunaan keduanya yang tumpang tindih. Aplikasi dapat menggunakan bahasa ekspresi saja, meskipun harus menentukan sistemnya sendiri untuk menerjemahkan konsep aplikasi ke dalam kueri basis data individual. Pernyataan bahasa Ekspresi akan diterjemahkan ke dalam kueri SQL mentah yang sesuai oleh mesin SQLAlchemy. Sekarang kita akan mempelajari cara membuat mesin dan menjalankan berbagai kueri SQL dengan bantuannya.","title":"Expression Language"},{"location":"docs/Multiple-Table-Deletes/","text":"Menghapus Beberapa Tabel \u00b6 Dalam bab ini, kita akan melihat ekspresi Multiple Table Deletes yang mirip dengan menggunakan fungsi Multiple Table Updates. Lebih dari satu tabel dapat dirujuk dalam klausa WHERE dari pernyataan DELETE dalam banyak dialek DBMS. Untuk PG dan MySQL, sintaks \"DELETE USING\" digunakan; dan untuk SQL Server, menggunakan ekspresi \"DELETE FROM\" mengacu pada lebih dari satu tabel. Konstruksi SQLAlchemy delete() mendukung kedua mode ini secara implisit, dengan menentukan beberapa tabel dalam klausa WHERE sebagai berikut stmt = users . delete () . \\ where ( users . c . id == addresses . c . id ) . \\ where ( addresses . c . email_address . startswith ( 'xyz%' )) conn . execute ( stmt ) output error karena SQLite tidak mendukung multi-table DELETE Pada backend PostgreSQL, SQL yang dihasilkan dari pernyataan di atas akan dirender sebagai DELETE FROM users USING addresses WHERE users . id = addresses . id AND ( addresses . email_address LIKE % ( email_address_1 ) s || '%%' ) Jika metode ini digunakan dengan database yang tidak mendukung perilaku ini, kompiler akan memunculkan NotImplementedError.","title":"Index"},{"location":"docs/Multiple-Table-Deletes/#menghapus-beberapa-tabel","text":"Dalam bab ini, kita akan melihat ekspresi Multiple Table Deletes yang mirip dengan menggunakan fungsi Multiple Table Updates. Lebih dari satu tabel dapat dirujuk dalam klausa WHERE dari pernyataan DELETE dalam banyak dialek DBMS. Untuk PG dan MySQL, sintaks \"DELETE USING\" digunakan; dan untuk SQL Server, menggunakan ekspresi \"DELETE FROM\" mengacu pada lebih dari satu tabel. Konstruksi SQLAlchemy delete() mendukung kedua mode ini secara implisit, dengan menentukan beberapa tabel dalam klausa WHERE sebagai berikut stmt = users . delete () . \\ where ( users . c . id == addresses . c . id ) . \\ where ( addresses . c . email_address . startswith ( 'xyz%' )) conn . execute ( stmt ) output error karena SQLite tidak mendukung multi-table DELETE Pada backend PostgreSQL, SQL yang dihasilkan dari pernyataan di atas akan dirender sebagai DELETE FROM users USING addresses WHERE users . id = addresses . id AND ( addresses . email_address LIKE % ( email_address_1 ) s || '%%' ) Jika metode ini digunakan dengan database yang tidak mendukung perilaku ini, kompiler akan memunculkan NotImplementedError.","title":"Menghapus Beberapa Tabel"},{"location":"docs/Multiple-Table-Updates/","text":"Update Beberapa Tabel \u00b6 Pada bab sebelumnya, kita telah membahas tentang cara menggunakan banyak tabel. Jadi kami melangkah lebih jauh dan mempelajari beberapa pembaruan tabel di bab ini. Menggunakan objek tabel SQLAlchemy, lebih dari satu tabel dapat ditentukan dalam klausa WHERE dari metode update(). PostgreSQL dan Microsoft SQL Server mendukung pernyataan UPDATE yang merujuk ke beberapa tabel. Ini mengimplementasikan sintaks \"UPDATE FROM\" , yang memperbarui satu tabel pada satu waktu. Namun, tabel tambahan dapat direferensikan dalam klausa \"DARI\" tambahan di klausa WHERE secara langsung. Baris kode berikut menjelaskan konsep pembaruan beberapa tabel dengan jelas. stmt = students . update () . \\ values ({ students . c . name : 'xyz' , addresses . c . email_add : 'abc@xyz.com' }) . \\ where ( students . c . id == addresses . c . id ) Objek pembaruan setara dengan permintaan UPDATE berikut UPDATE students SET email_add = : addresses_email_add , name = : name FROM addresses WHERE students . id = addresses . id Sejauh menyangkut dialek MySQL, banyak tabel dapat disematkan ke dalam satu pernyataan UPDATE yang dipisahkan oleh koma seperti yang diberikan di bawah ini stmt = students . update () . \\ values ( name = 'xyz' ) . \\ where ( students . c . id == addresses . c . id ) Kode berikut menggambarkan kueri UPDATE yang dihasilkan 'UPDATE students SET name = :name FROM addresses WHERE students.id = addresses.id' Namun dialek SQLite tidak mendukung kriteria multi-tabel dalam UPDATE dan menunjukkan kesalahan berikut NotImplementedError : This backend does not support multiple - table criteria within UPDATE","title":"Index"},{"location":"docs/Multiple-Table-Updates/#update-beberapa-tabel","text":"Pada bab sebelumnya, kita telah membahas tentang cara menggunakan banyak tabel. Jadi kami melangkah lebih jauh dan mempelajari beberapa pembaruan tabel di bab ini. Menggunakan objek tabel SQLAlchemy, lebih dari satu tabel dapat ditentukan dalam klausa WHERE dari metode update(). PostgreSQL dan Microsoft SQL Server mendukung pernyataan UPDATE yang merujuk ke beberapa tabel. Ini mengimplementasikan sintaks \"UPDATE FROM\" , yang memperbarui satu tabel pada satu waktu. Namun, tabel tambahan dapat direferensikan dalam klausa \"DARI\" tambahan di klausa WHERE secara langsung. Baris kode berikut menjelaskan konsep pembaruan beberapa tabel dengan jelas. stmt = students . update () . \\ values ({ students . c . name : 'xyz' , addresses . c . email_add : 'abc@xyz.com' }) . \\ where ( students . c . id == addresses . c . id ) Objek pembaruan setara dengan permintaan UPDATE berikut UPDATE students SET email_add = : addresses_email_add , name = : name FROM addresses WHERE students . id = addresses . id Sejauh menyangkut dialek MySQL, banyak tabel dapat disematkan ke dalam satu pernyataan UPDATE yang dipisahkan oleh koma seperti yang diberikan di bawah ini stmt = students . update () . \\ values ( name = 'xyz' ) . \\ where ( students . c . id == addresses . c . id ) Kode berikut menggambarkan kueri UPDATE yang dihasilkan 'UPDATE students SET name = :name FROM addresses WHERE students.id = addresses.id' Namun dialek SQLite tidak mendukung kriteria multi-tabel dalam UPDATE dan menunjukkan kesalahan berikut NotImplementedError : This backend does not support multiple - table criteria within UPDATE","title":"Update Beberapa Tabel"},{"location":"docs/Ordered-Updates/","text":"Update Parameter Berurutan \u00b6 Kueri UPDATE dari SQL mentah memiliki klausa SET. Ini dirender oleh konstruksi update() menggunakan pengurutan kolom yang diberikan dalam objek Tabel asal. Oleh karena itu, pernyataan UPDATE tertentu dengan kolom tertentu akan dirender sama setiap saat. Karena parameter itu sendiri diteruskan ke metode Update.values() sebagai kunci kamus Python, tidak ada pengurutan tetap lain yang tersedia. Dalam beberapa kasus, urutan parameter yang diberikan dalam klausa SET signifikan. Di MySQL, menyediakan pembaruan untuk nilai kolom didasarkan pada nilai kolom lainnya. Berikut hasil pernyataan UPDATE table1 SET x = y + 10 , y = 20 akan memiliki hasil yang berbeda dari UPDATE table1 SET y = 20 , x = y + 10 Klausa SET di MySQL dievaluasi berdasarkan per nilai dan bukan berdasarkan per baris. Untuk tujuan ini, preserved_parameter_order digunakan. Daftar 2-tupel Python diberikan sebagai argumen untuk metode Update.values() stmt = table1 . update ( preserve_parameter_order = True ) . \\ values ([( table1 . c . y , 20 ), ( table1 . c . x , table1 . c . y + 10 )]) Objek Daftar mirip dengan kamus kecuali yang dipesan. Ini memastikan bahwa klausa SET kolom \"y\" akan dirender terlebih dahulu, kemudian klausa SET kolom \"x\".","title":"Parameter Ordered Update"},{"location":"docs/Ordered-Updates/#update-parameter-berurutan","text":"Kueri UPDATE dari SQL mentah memiliki klausa SET. Ini dirender oleh konstruksi update() menggunakan pengurutan kolom yang diberikan dalam objek Tabel asal. Oleh karena itu, pernyataan UPDATE tertentu dengan kolom tertentu akan dirender sama setiap saat. Karena parameter itu sendiri diteruskan ke metode Update.values() sebagai kunci kamus Python, tidak ada pengurutan tetap lain yang tersedia. Dalam beberapa kasus, urutan parameter yang diberikan dalam klausa SET signifikan. Di MySQL, menyediakan pembaruan untuk nilai kolom didasarkan pada nilai kolom lainnya. Berikut hasil pernyataan UPDATE table1 SET x = y + 10 , y = 20 akan memiliki hasil yang berbeda dari UPDATE table1 SET y = 20 , x = y + 10 Klausa SET di MySQL dievaluasi berdasarkan per nilai dan bukan berdasarkan per baris. Untuk tujuan ini, preserved_parameter_order digunakan. Daftar 2-tupel Python diberikan sebagai argumen untuk metode Update.values() stmt = table1 . update ( preserve_parameter_order = True ) . \\ values ([( table1 . c . y , 20 ), ( table1 . c . x , table1 . c . y + 10 )]) Objek Daftar mirip dengan kamus kecuali yang dipesan. Ini memastikan bahwa klausa SET kolom \"y\" akan dirender terlebih dahulu, kemudian klausa SET kolom \"x\".","title":"Update Parameter Berurutan"},{"location":"docs/SQL-Expressions/","text":"SQL Expression \u00b6 Ekspresi SQL dibangun menggunakan metode yang sesuai relatif terhadap objek tabel target. Misalnya, pernyataan INSERT dibuat dengan mengeksekusi metode insert() sebagai berikut ins = students . insert () Hasil dari metode di atas adalah objek sisipan yang dapat diverifikasi dengan menggunakan fungsi str(). Kode di bawah ini menyisipkan detail seperti id siswa, nama, nama belakang. 'INSERT INTO students (id, name, lastname) VALUES (:id, :name, :lastname)' Dimungkinkan untuk memasukkan nilai dalam bidang tertentu dengan metode values() untuk memasukkan objek. Kode untuk hal yang sama diberikan di bawah ini >>> ins = users . insert () . values ( name = 'Karan' ) >>> str ( ins ) 'INSERT INTO users (name) VALUES (:name)' SQL yang bergema di konsol Python tidak menunjukkan nilai sebenarnya ('Karan' dalam kasus ini). Sebagai gantinya, SQLALchemy menghasilkan parameter bind yang terlihat dalam bentuk pernyataan yang dikompilasi. ins . compile () . params { 'name' : 'Karan' } Demikian pula, metode seperti update(), delete() dan select() masing-masing membuat ekspresi UPDATE, DELETE dan SELECT. Kita akan belajar tentang mereka di bab-bab selanjutnya.","title":"Index"},{"location":"docs/SQL-Expressions/#sql-expression","text":"Ekspresi SQL dibangun menggunakan metode yang sesuai relatif terhadap objek tabel target. Misalnya, pernyataan INSERT dibuat dengan mengeksekusi metode insert() sebagai berikut ins = students . insert () Hasil dari metode di atas adalah objek sisipan yang dapat diverifikasi dengan menggunakan fungsi str(). Kode di bawah ini menyisipkan detail seperti id siswa, nama, nama belakang. 'INSERT INTO students (id, name, lastname) VALUES (:id, :name, :lastname)' Dimungkinkan untuk memasukkan nilai dalam bidang tertentu dengan metode values() untuk memasukkan objek. Kode untuk hal yang sama diberikan di bawah ini >>> ins = users . insert () . values ( name = 'Karan' ) >>> str ( ins ) 'INSERT INTO users (name) VALUES (:name)' SQL yang bergema di konsol Python tidak menunjukkan nilai sebenarnya ('Karan' dalam kasus ini). Sebagai gantinya, SQLALchemy menghasilkan parameter bind yang terlihat dalam bentuk pernyataan yang dikompilasi. ins . compile () . params { 'name' : 'Karan' } Demikian pula, metode seperti update(), delete() dan select() masing-masing membuat ekspresi UPDATE, DELETE dan SELECT. Kita akan belajar tentang mereka di bab-bab selanjutnya.","title":"SQL Expression"},{"location":"docs/Selecting-Rows/","text":"Memilih Baris \u00b6 Metode select() dari objek tabel memungkinkan kita membuat ekspresi SELECT s = students . select () Objek select diterjemahkan ke kueri SELECT dengan fungsi str(s) seperti yang ditunjukkan di bawah ini 'SELECT students.id, students.name, students.lastname FROM students' Kita dapat menggunakan objek pilih ini sebagai parameter untuk mengeksekusi () metode objek koneksi seperti yang ditunjukkan pada kode di bawah ini result = conn . execute ( s ) Ketika pernyataan di atas dijalankan, shell Python bergema mengikuti ekspresi SQL yang setara SELECT students . id , students . name , students . lastname FROM students Variabel yang dihasilkan setara dengan kursor di DBAPI. Kita sekarang dapat mengambil rekaman menggunakan metode fetchone() . row = result . fetchone () Semua baris yang dipilih dalam tabel dapat dicetak oleh for loop seperti yang diberikan di bawah ini for row in result : print ( row ) Kode lengkap untuk mencetak semua baris dari tabel siswa ditunjukkan di bawah in from sqlalchemy import create_engine , MetaData , Table , Column , Integer , String engine = create_engine ( 'sqlite:///college.db' , echo = True ) meta = MetaData () students = Table ( 'students' , meta , Column ( 'id' , Integer , primary_key = True ), Column ( 'name' , String ), Column ( 'lastname' , String ), ) s = students . select () conn = engine . connect () result = conn . execute ( s ) for row in result : print ( row ) Di sini atribut c adalah alias untuk column . Output berikut akan ditampilkan di shell (1, 'Ahmad', 'Haidir') (2, 'Bob', 'Chrismansayah') (3, 'Ariandini', 'Aulia') (4, 'Bob', 'Langau') (5, 'Aiandini', 'Dini') (6, 'Haidir', 'Ahmed') (7, 'Masuk', 'Saja') Hasil run sebagai berikut \u00b6 Di sini, kita harus mencatat bahwa objek pilih juga dapat diperoleh dengan fungsi select() dalam modul sqlalchemy.sql. Fungsi select() memerlukan objek tabel sebagai argumen. from sqlalchemy.sql import select s = select ([ users ]) result = conn . execute ( s ) # perulangan untuk mencetak select # for row in result: # print (row) Hasilnya akan sama seperti di atas.","title":"Selecting Rows"},{"location":"docs/Selecting-Rows/#memilih-baris","text":"Metode select() dari objek tabel memungkinkan kita membuat ekspresi SELECT s = students . select () Objek select diterjemahkan ke kueri SELECT dengan fungsi str(s) seperti yang ditunjukkan di bawah ini 'SELECT students.id, students.name, students.lastname FROM students' Kita dapat menggunakan objek pilih ini sebagai parameter untuk mengeksekusi () metode objek koneksi seperti yang ditunjukkan pada kode di bawah ini result = conn . execute ( s ) Ketika pernyataan di atas dijalankan, shell Python bergema mengikuti ekspresi SQL yang setara SELECT students . id , students . name , students . lastname FROM students Variabel yang dihasilkan setara dengan kursor di DBAPI. Kita sekarang dapat mengambil rekaman menggunakan metode fetchone() . row = result . fetchone () Semua baris yang dipilih dalam tabel dapat dicetak oleh for loop seperti yang diberikan di bawah ini for row in result : print ( row ) Kode lengkap untuk mencetak semua baris dari tabel siswa ditunjukkan di bawah in from sqlalchemy import create_engine , MetaData , Table , Column , Integer , String engine = create_engine ( 'sqlite:///college.db' , echo = True ) meta = MetaData () students = Table ( 'students' , meta , Column ( 'id' , Integer , primary_key = True ), Column ( 'name' , String ), Column ( 'lastname' , String ), ) s = students . select () conn = engine . connect () result = conn . execute ( s ) for row in result : print ( row ) Di sini atribut c adalah alias untuk column . Output berikut akan ditampilkan di shell (1, 'Ahmad', 'Haidir') (2, 'Bob', 'Chrismansayah') (3, 'Ariandini', 'Aulia') (4, 'Bob', 'Langau') (5, 'Aiandini', 'Dini') (6, 'Haidir', 'Ahmed') (7, 'Masuk', 'Saja')","title":"Memilih Baris"},{"location":"docs/Selecting-Rows/#hasil-run-sebagai-berikut","text":"Di sini, kita harus mencatat bahwa objek pilih juga dapat diperoleh dengan fungsi select() dalam modul sqlalchemy.sql. Fungsi select() memerlukan objek tabel sebagai argumen. from sqlalchemy.sql import select s = select ([ users ]) result = conn . execute ( s ) # perulangan untuk mencetak select # for row in result: # print (row) Hasilnya akan sama seperti di atas.","title":"Hasil run sebagai berikut"},{"location":"docs/Update-Expression/","text":"Menggunakan UPDATE Expression \u00b6 Metode update() pada objek tabel target membuat ekspresi SQL UPDATE yang setara. table . update () . where ( conditions ) . values ( SET expressions ) Metode values() pada objek update yang dihasilkan digunakan untuk menentukan kondisi SET dari UPDATE. Jika dibiarkan sebagai Tidak Ada, kondisi SET ditentukan dari parameter yang diteruskan ke pernyataan selama eksekusi dan/atau kompilasi pernyataan. Klausa where() adalah ekspresi Opsional yang menjelaskan kondisi WHERE dari pernyataan UPDATE. Cuplikan kode berikut mengubah nilai kolom 'nama belakang' dari 'Saja' menjadi 'Sajami' di tabel siswa stmt = students . update () . where ( students . c . lastname == 'Saja' ) . values ( lastname = 'Sajami' ) 'UPDATE students SET lastname = :lastname WHERE students.lastname = :lastname_1' Parameter terikat lastname_1 akan diganti saat metode execution() dipanggil. Kode pembaruan lengkap diberikan di bawah ini from sqlalchemy import create_engine , MetaData , Table , Column , Integer , String engine = create_engine ( 'sqlite:///college.db' , echo = True ) meta = MetaData () students = Table ( 'students' , meta , Column ( 'id' , Integer , primary_key = True ), Column ( 'name' , String ), Column ( 'lastname' , String ), ) conn = engine . connect () stmt = students . update () . where ( students . c . lastname == 'Saja' ) . values ( lastname = 'Sajami' ) conn . execute ( stmt ) s = students . select () conn . execute ( s ) . fetchall () Kode di atas menampilkan keluaran berikut dengan baris kedua yang menunjukkan efek operasi pembaruan seperti pada tangkapan layar yang diberikan (1, 'Ahmad', 'Haidir') (2, 'Bob', 'Chrismansayah') (3, 'Ariandini', 'Aulia') (4, 'Bob', 'Langau') (5, 'Aiandini', 'Dini') (6, 'Haidir', 'Ahmed') (7, 'Masuk', 'Sajami') Perhatikan bahwa fungsionalitas serupa juga dapat dicapai dengan menggunakan fungsi update() dalam modul sqlalchemy.sql.expression seperti yang ditunjukkan di bawah ini from sqlalchemy.sql.expression import update stmt = update ( students ) . where ( students . c . lastname == 'Sajami' ) . values ( lastname = 'Lagi' ) Hasilnya seperti berikut (1, 'Ahmad', 'Haidir') (2, 'Bob', 'Chrismansayah') (3, 'Ariandini', 'Aulia') (4, 'Bob', 'Langau') (5, 'Aiandini', 'Dini') (6, 'Haidir', 'Ahmed') (7, 'Masuk', 'Lagi')","title":"Update Expression"},{"location":"docs/Update-Expression/#menggunakan-update-expression","text":"Metode update() pada objek tabel target membuat ekspresi SQL UPDATE yang setara. table . update () . where ( conditions ) . values ( SET expressions ) Metode values() pada objek update yang dihasilkan digunakan untuk menentukan kondisi SET dari UPDATE. Jika dibiarkan sebagai Tidak Ada, kondisi SET ditentukan dari parameter yang diteruskan ke pernyataan selama eksekusi dan/atau kompilasi pernyataan. Klausa where() adalah ekspresi Opsional yang menjelaskan kondisi WHERE dari pernyataan UPDATE. Cuplikan kode berikut mengubah nilai kolom 'nama belakang' dari 'Saja' menjadi 'Sajami' di tabel siswa stmt = students . update () . where ( students . c . lastname == 'Saja' ) . values ( lastname = 'Sajami' ) 'UPDATE students SET lastname = :lastname WHERE students.lastname = :lastname_1' Parameter terikat lastname_1 akan diganti saat metode execution() dipanggil. Kode pembaruan lengkap diberikan di bawah ini from sqlalchemy import create_engine , MetaData , Table , Column , Integer , String engine = create_engine ( 'sqlite:///college.db' , echo = True ) meta = MetaData () students = Table ( 'students' , meta , Column ( 'id' , Integer , primary_key = True ), Column ( 'name' , String ), Column ( 'lastname' , String ), ) conn = engine . connect () stmt = students . update () . where ( students . c . lastname == 'Saja' ) . values ( lastname = 'Sajami' ) conn . execute ( stmt ) s = students . select () conn . execute ( s ) . fetchall () Kode di atas menampilkan keluaran berikut dengan baris kedua yang menunjukkan efek operasi pembaruan seperti pada tangkapan layar yang diberikan (1, 'Ahmad', 'Haidir') (2, 'Bob', 'Chrismansayah') (3, 'Ariandini', 'Aulia') (4, 'Bob', 'Langau') (5, 'Aiandini', 'Dini') (6, 'Haidir', 'Ahmed') (7, 'Masuk', 'Sajami') Perhatikan bahwa fungsionalitas serupa juga dapat dicapai dengan menggunakan fungsi update() dalam modul sqlalchemy.sql.expression seperti yang ditunjukkan di bawah ini from sqlalchemy.sql.expression import update stmt = update ( students ) . where ( students . c . lastname == 'Sajami' ) . values ( lastname = 'Lagi' ) Hasilnya seperti berikut (1, 'Ahmad', 'Haidir') (2, 'Bob', 'Chrismansayah') (3, 'Ariandini', 'Aulia') (4, 'Bob', 'Langau') (5, 'Aiandini', 'Dini') (6, 'Haidir', 'Ahmed') (7, 'Masuk', 'Lagi')","title":"Menggunakan UPDATE Expression"},{"location":"docs/Using-Aliases/","text":"Menggunakan Alias \u00b6 Alias \u200b\u200b\u200b\u200bdalam SQL sesuai dengan versi \"berganti nama\" dari tabel atau pernyataan SELECT, yang terjadi kapan saja Anda mengatakan \"SELECT * FROM table1 AS a\". AS membuat nama baru untuk tabel. Alias \u200b\u200b\u200b\u200bmemungkinkan setiap tabel atau subkueri direferensikan dengan nama unik. Dalam kasus tabel, ini memungkinkan tabel yang sama diberi nama dalam klausa FROM berkali-kali. Ini memberikan nama induk untuk kolom yang diwakili oleh pernyataan, yang memungkinkan mereka untuk direferensikan relatif terhadap nama ini. Dalam SQLAlchemy, setiap Tabel, konstruk select(), atau objek lain yang dapat dipilih dapat diubah menjadi alias menggunakan metode From Clause.alias(), yang menghasilkan konstruksi Alias. Fungsi alias() dalam modul sqlalchemy.sql mewakili sebuah alias, seperti yang biasanya diterapkan pada tabel atau sub-pilihan apa pun dalam pernyataan SQL menggunakan kata kunci AS. from sqlalchemy.sql import alias st = student . alias ( \"a\" ) Alias \u200b\u200b\u200b\u200bini sekarang dapat digunakan dalam konstruk select() untuk merujuk ke tabel siswa s = select ([ st ]) . where ( st . c . id > 2 ) Ini diterjemahkan menjadi ekspresi SQL sebagai berikut SELECT a . id , a . name , a . lastname FROM students AS a WHERE a . id > 2 Kita sekarang dapat mengeksekusi kueri SQL ini dengan metode execution() dari objek koneksi. Kode lengkapnya adalah sebagai berikut from sqlalchemy.sql import alias , select st = students . alias ( \"a\" ) s = select ([ st ]) . where ( st . c . id > 2 ) conn . execute ( s ) . fetchall () Ketika baris kode di atas dijalankan, itu menghasilkan keluaran berikut (2,) (3, 'Ariandini', 'Aulia') (4, 'Bob', 'Langau') (5, 'Aiandini', 'Dini') (6, 'Haidir', 'Ahmed') (7, 'Masuk', 'Saja')","title":"Using Aliases"},{"location":"docs/Using-Aliases/#menggunakan-alias","text":"Alias \u200b\u200b\u200b\u200bdalam SQL sesuai dengan versi \"berganti nama\" dari tabel atau pernyataan SELECT, yang terjadi kapan saja Anda mengatakan \"SELECT * FROM table1 AS a\". AS membuat nama baru untuk tabel. Alias \u200b\u200b\u200b\u200bmemungkinkan setiap tabel atau subkueri direferensikan dengan nama unik. Dalam kasus tabel, ini memungkinkan tabel yang sama diberi nama dalam klausa FROM berkali-kali. Ini memberikan nama induk untuk kolom yang diwakili oleh pernyataan, yang memungkinkan mereka untuk direferensikan relatif terhadap nama ini. Dalam SQLAlchemy, setiap Tabel, konstruk select(), atau objek lain yang dapat dipilih dapat diubah menjadi alias menggunakan metode From Clause.alias(), yang menghasilkan konstruksi Alias. Fungsi alias() dalam modul sqlalchemy.sql mewakili sebuah alias, seperti yang biasanya diterapkan pada tabel atau sub-pilihan apa pun dalam pernyataan SQL menggunakan kata kunci AS. from sqlalchemy.sql import alias st = student . alias ( \"a\" ) Alias \u200b\u200b\u200b\u200bini sekarang dapat digunakan dalam konstruk select() untuk merujuk ke tabel siswa s = select ([ st ]) . where ( st . c . id > 2 ) Ini diterjemahkan menjadi ekspresi SQL sebagai berikut SELECT a . id , a . name , a . lastname FROM students AS a WHERE a . id > 2 Kita sekarang dapat mengeksekusi kueri SQL ini dengan metode execution() dari objek koneksi. Kode lengkapnya adalah sebagai berikut from sqlalchemy.sql import alias , select st = students . alias ( \"a\" ) s = select ([ st ]) . where ( st . c . id > 2 ) conn . execute ( s ) . fetchall () Ketika baris kode di atas dijalankan, itu menghasilkan keluaran berikut (2,) (3, 'Ariandini', 'Aulia') (4, 'Bob', 'Langau') (5, 'Aiandini', 'Dini') (6, 'Haidir', 'Ahmed') (7, 'Masuk', 'Saja')","title":"Menggunakan Alias"},{"location":"docs/Using-Conjunctions/","text":"Menggunakan Konjungsi \u00b6 Konjungsi adalah fungsi dalam modul SQLAlchemy yang mengimplementasikan operator relasional yang digunakan dalam klausa WHERE ekspresi SQL. Operator AND, OR, NOT, dll., digunakan untuk membentuk ekspresi majemuk yang menggabungkan dua ekspresi logis individual. Contoh sederhana penggunaan AND dalam pernyataan SELECT adalah sebagai berikut SELECT * from EMPLOYEE WHERE salary > 10000 AND age > 30 Fungsi SQLAlchemy and_(), or_() dan not_() masing-masing mengimplementasikan operator AND, OR dan NOT. and_() function \u00b6 Ini menghasilkan konjungsi ekspresi yang digabungkan oleh AND. Contoh diberikan di bawah ini untuk pemahaman yang lebih baik from sqlalchemy import and_ print ( and_ ( students . c . name == 'Ravi' , students . c . id < 3 ) ) Ini diterjemahkan menjadi students . name = : name_1 AND students . id < : id_1 Untuk menggunakan and_() dalam konstruksi select() pada tabel siswa, gunakan baris kode berikut stmt = select ([ students ]) . where ( and_ ( students . c . name == 'Ravi' , students . c . id < 3 )) Pernyataan SELECT dari sifat berikut akan dibangun SELECT students . id , students . name , students . lastname FROM students WHERE students . name = : name_1 AND students . id < : id_1 Kode lengkap yang menampilkan keluaran dari kueri SELECT di atas adalah sebagai berikut from sqlalchemy import create_engine , MetaData , Table , Column , Integer , String , ForeignKey , select engine = create_engine ( 'sqlite:///college.db' , echo = True ) meta = MetaData () conn = engine . connect () students = Table ( 'students' , meta , Column ( 'id' , Integer , primary_key = True ), Column ( 'name' , String ), Column ( 'lastname' , String ), ) from sqlalchemy import and_ , or_ stmt = select ([ students ]) . where ( and_ ( students . c . name == 'Ariandini' , students . c . id < 3 )) result = conn . execute ( stmt ) print ( result . fetchall ()) output ('Ariandini', 3) (2, 'Ariandini', 'Aulia') or_() function \u00b6 Ini menghasilkan konjungsi ekspresi yang digabungkan dengan ATAU. Kami akan mengganti objek stmt dalam contoh di atas dengan yang berikut menggunakan or_() stmt = select ([ students ]) . where ( or_ ( students . c . name == 'Ahmad' , students . c . id < 3 )) Yang akan secara efektif setara dengan mengikuti kueri SELECT SELECT students . id , students . name , students . lastname FROM students WHERE students . name = : name_1 OR students . id < : id_1 Setelah Anda membuat substitusi dan menjalankan kode di atas, hasilnya adalah dua baris yang berada dalam kondisi OR (1, 'Bob', 'Chrismansyah') (2, 'Ariandini', 'Aulia') asc() function \u00b6 Ini menghasilkan klausa ORDER BY naik. Fungsi mengambil kolom untuk menerapkan fungsi sebagai parameter. from sqlalchemy import asc stmt = select ([ students ]) . order_by ( asc ( students . c . name )) Pernyataan tersebut mengimplementasikan ekspresi SQL berikut SELECT students . id , students . name , students . lastname FROM students ORDER BY students . name ASC Kode berikut mencantumkan semua catatan dalam tabel siswa dalam urutan menaik kolom nama from sqlalchemy import asc stmt = select ([ students ]) . order_by ( asc ( students . c . name )) result = conn . execute ( stmt ) for row in result : print ( row ) Kode di atas menghasilkan keluaran berikut (3, 'Ahmad', 'Haidir') (2, 'Ariandini', 'Aulia') (1, 'Bob', 'Chrismansyah') desc() function Demikian pula fungsi desc() menghasilkan klausa ORDER BY menurun sebagai berikut from sqlalchemy import desc stmt = select ([ students ]) . order_by ( desc ( students . c . lastname )) Ekspresi SQL yang setara adalah SELECT students . id , students . name , students . lastname FROM students Dan output untuk baris kode di atas adalah (3, 'Ahmad', 'Haidir') (1, 'Bob', 'Chrismansyah') (2, 'Ariandini', 'Aulia') between() function \u00b6 Ini menghasilkan klausa predikat BETWEEN. Ini umumnya digunakan untuk memvalidasi jika nilai kolom tertentu berada di antara rentang. Misalnya, kode berikut memilih baris dengan kolom id antara 2 dan 4 from sqlalchemy import between stmt = select ([ students ]) . where ( between ( students . c . id , 2 , 3 )) print ( stmt ) Ekspresi SQL adalah SELECT students . id , students . name , students . lastname FROM students WHERE students . id BETWEEN : id_1 AND : id_3 dan hasilnya adalah sebagai berikut (2, 'Ariandini', 'Aulia') (3, 'Ahmad', 'Haidir')","title":"Using Conjunctions"},{"location":"docs/Using-Conjunctions/#menggunakan-konjungsi","text":"Konjungsi adalah fungsi dalam modul SQLAlchemy yang mengimplementasikan operator relasional yang digunakan dalam klausa WHERE ekspresi SQL. Operator AND, OR, NOT, dll., digunakan untuk membentuk ekspresi majemuk yang menggabungkan dua ekspresi logis individual. Contoh sederhana penggunaan AND dalam pernyataan SELECT adalah sebagai berikut SELECT * from EMPLOYEE WHERE salary > 10000 AND age > 30 Fungsi SQLAlchemy and_(), or_() dan not_() masing-masing mengimplementasikan operator AND, OR dan NOT.","title":"Menggunakan Konjungsi"},{"location":"docs/Using-Conjunctions/#and_-function","text":"Ini menghasilkan konjungsi ekspresi yang digabungkan oleh AND. Contoh diberikan di bawah ini untuk pemahaman yang lebih baik from sqlalchemy import and_ print ( and_ ( students . c . name == 'Ravi' , students . c . id < 3 ) ) Ini diterjemahkan menjadi students . name = : name_1 AND students . id < : id_1 Untuk menggunakan and_() dalam konstruksi select() pada tabel siswa, gunakan baris kode berikut stmt = select ([ students ]) . where ( and_ ( students . c . name == 'Ravi' , students . c . id < 3 )) Pernyataan SELECT dari sifat berikut akan dibangun SELECT students . id , students . name , students . lastname FROM students WHERE students . name = : name_1 AND students . id < : id_1 Kode lengkap yang menampilkan keluaran dari kueri SELECT di atas adalah sebagai berikut from sqlalchemy import create_engine , MetaData , Table , Column , Integer , String , ForeignKey , select engine = create_engine ( 'sqlite:///college.db' , echo = True ) meta = MetaData () conn = engine . connect () students = Table ( 'students' , meta , Column ( 'id' , Integer , primary_key = True ), Column ( 'name' , String ), Column ( 'lastname' , String ), ) from sqlalchemy import and_ , or_ stmt = select ([ students ]) . where ( and_ ( students . c . name == 'Ariandini' , students . c . id < 3 )) result = conn . execute ( stmt ) print ( result . fetchall ()) output ('Ariandini', 3) (2, 'Ariandini', 'Aulia')","title":"and_() function"},{"location":"docs/Using-Conjunctions/#or_-function","text":"Ini menghasilkan konjungsi ekspresi yang digabungkan dengan ATAU. Kami akan mengganti objek stmt dalam contoh di atas dengan yang berikut menggunakan or_() stmt = select ([ students ]) . where ( or_ ( students . c . name == 'Ahmad' , students . c . id < 3 )) Yang akan secara efektif setara dengan mengikuti kueri SELECT SELECT students . id , students . name , students . lastname FROM students WHERE students . name = : name_1 OR students . id < : id_1 Setelah Anda membuat substitusi dan menjalankan kode di atas, hasilnya adalah dua baris yang berada dalam kondisi OR (1, 'Bob', 'Chrismansyah') (2, 'Ariandini', 'Aulia')","title":"or_() function"},{"location":"docs/Using-Conjunctions/#asc-function","text":"Ini menghasilkan klausa ORDER BY naik. Fungsi mengambil kolom untuk menerapkan fungsi sebagai parameter. from sqlalchemy import asc stmt = select ([ students ]) . order_by ( asc ( students . c . name )) Pernyataan tersebut mengimplementasikan ekspresi SQL berikut SELECT students . id , students . name , students . lastname FROM students ORDER BY students . name ASC Kode berikut mencantumkan semua catatan dalam tabel siswa dalam urutan menaik kolom nama from sqlalchemy import asc stmt = select ([ students ]) . order_by ( asc ( students . c . name )) result = conn . execute ( stmt ) for row in result : print ( row ) Kode di atas menghasilkan keluaran berikut (3, 'Ahmad', 'Haidir') (2, 'Ariandini', 'Aulia') (1, 'Bob', 'Chrismansyah') desc() function Demikian pula fungsi desc() menghasilkan klausa ORDER BY menurun sebagai berikut from sqlalchemy import desc stmt = select ([ students ]) . order_by ( desc ( students . c . lastname )) Ekspresi SQL yang setara adalah SELECT students . id , students . name , students . lastname FROM students Dan output untuk baris kode di atas adalah (3, 'Ahmad', 'Haidir') (1, 'Bob', 'Chrismansyah') (2, 'Ariandini', 'Aulia')","title":"asc() function"},{"location":"docs/Using-Conjunctions/#between-function","text":"Ini menghasilkan klausa predikat BETWEEN. Ini umumnya digunakan untuk memvalidasi jika nilai kolom tertentu berada di antara rentang. Misalnya, kode berikut memilih baris dengan kolom id antara 2 dan 4 from sqlalchemy import between stmt = select ([ students ]) . where ( between ( students . c . id , 2 , 3 )) print ( stmt ) Ekspresi SQL adalah SELECT students . id , students . name , students . lastname FROM students WHERE students . id BETWEEN : id_1 AND : id_3 dan hasilnya adalah sebagai berikut (2, 'Ariandini', 'Aulia') (3, 'Ahmad', 'Haidir')","title":"between() function"},{"location":"docs/Using-Functions/","text":"Menggunakan Fungsi \u00b6 Beberapa fungsi penting yang digunakan dalam SQLAlchemy dibahas dalam bab ini. SQL standar telah merekomendasikan banyak fungsi yang diimplementasikan oleh sebagian besar dialek. Mereka mengembalikan satu nilai berdasarkan argumen yang diteruskan ke sana. Beberapa fungsi SQL mengambil kolom sebagai argumen sedangkan beberapa bersifat umum. Kata kunci thefunc di SQLAlchemy API digunakan untuk menghasilkan fungsi-fungsi ini . Dalam SQL, now() adalah fungsi generik. Pernyataan berikut merender fungsi now() menggunakan func from sqlalchemy.sql import func result = conn . execute ( select ([ func . now ()])) print ( result . fetchone ()) Contoh hasil kode di atas mungkin seperti yang ditunjukkan di bawah ini (datetime.datetime(2022, 11, 21, 5, 31, 16),) Di sisi lain, fungsi count() yang mengembalikan jumlah baris yang dipilih dari sebuah tabel, dirender dengan mengikuti penggunaan func from sqlalchemy.sql import func result = conn . execute ( select ([ func . count ( students . c . id )])) print ( result . fetchone ()) Contoh hasil kode di atas mungkin seperti yang ditunjukkan di bawah ini (3,) Dari kode di atas, akan diambil jumlah baris pada tabel students. Beberapa fungsi SQL bawaan didemonstrasikan menggunakan tabel Karyawan dengan data berikut id name lastname 1 Bob Chrismansyah 2 Ariandini Aulia 3 Ahmad Haidir Fungsi max() \u00b6 Fungsi max() diimplementasikan dengan mengikuti penggunaan func dari SQLAlchemy yang akan menghasilkan 85, total nilai maksimum yang diperoleh from sqlalchemy.sql import func result = conn . execute ( select ([ func . max ( students . c . id )])) print ( result . fetchone ()) Outputnya (3,) Fungsi min() \u00b6 Demikian pula, fungsi min() yang akan mengembalikan 56, tanda minimum, akan dirender dengan mengikuti kode from sqlalchemy.sql import func result = conn . execute ( select ([ func . min ( employee . c . marks )])) print ( result . fetchone ()) Outputnya (1,) fungsi AVG() \u00b6 bisa diimplementasikan dengan menggunakan kode di bawah ini from sqlalchemy.sql import func result = conn . execute ( select ([ func . avg ( employee . c . marks )])) print ( result . fetchone ()) Otuputnya (2.0,)","title":"Using Functions"},{"location":"docs/Using-Functions/#menggunakan-fungsi","text":"Beberapa fungsi penting yang digunakan dalam SQLAlchemy dibahas dalam bab ini. SQL standar telah merekomendasikan banyak fungsi yang diimplementasikan oleh sebagian besar dialek. Mereka mengembalikan satu nilai berdasarkan argumen yang diteruskan ke sana. Beberapa fungsi SQL mengambil kolom sebagai argumen sedangkan beberapa bersifat umum. Kata kunci thefunc di SQLAlchemy API digunakan untuk menghasilkan fungsi-fungsi ini . Dalam SQL, now() adalah fungsi generik. Pernyataan berikut merender fungsi now() menggunakan func from sqlalchemy.sql import func result = conn . execute ( select ([ func . now ()])) print ( result . fetchone ()) Contoh hasil kode di atas mungkin seperti yang ditunjukkan di bawah ini (datetime.datetime(2022, 11, 21, 5, 31, 16),) Di sisi lain, fungsi count() yang mengembalikan jumlah baris yang dipilih dari sebuah tabel, dirender dengan mengikuti penggunaan func from sqlalchemy.sql import func result = conn . execute ( select ([ func . count ( students . c . id )])) print ( result . fetchone ()) Contoh hasil kode di atas mungkin seperti yang ditunjukkan di bawah ini (3,) Dari kode di atas, akan diambil jumlah baris pada tabel students. Beberapa fungsi SQL bawaan didemonstrasikan menggunakan tabel Karyawan dengan data berikut id name lastname 1 Bob Chrismansyah 2 Ariandini Aulia 3 Ahmad Haidir","title":"Menggunakan Fungsi"},{"location":"docs/Using-Functions/#fungsi-max","text":"Fungsi max() diimplementasikan dengan mengikuti penggunaan func dari SQLAlchemy yang akan menghasilkan 85, total nilai maksimum yang diperoleh from sqlalchemy.sql import func result = conn . execute ( select ([ func . max ( students . c . id )])) print ( result . fetchone ()) Outputnya (3,)","title":"Fungsi max()"},{"location":"docs/Using-Functions/#fungsi-min","text":"Demikian pula, fungsi min() yang akan mengembalikan 56, tanda minimum, akan dirender dengan mengikuti kode from sqlalchemy.sql import func result = conn . execute ( select ([ func . min ( employee . c . marks )])) print ( result . fetchone ()) Outputnya (1,)","title":"Fungsi min()"},{"location":"docs/Using-Functions/#fungsi-avg","text":"bisa diimplementasikan dengan menggunakan kode di bawah ini from sqlalchemy.sql import func result = conn . execute ( select ([ func . avg ( employee . c . marks )])) print ( result . fetchone ()) Otuputnya (2.0,)","title":"fungsi AVG()"},{"location":"docs/Using-Joins/","text":"Menggunakan Joins \u00b6 Dalam bab ini, kita akan mempelajari cara menggunakan Gabungan di SQLAlchemy. Efek penggabungan dicapai dengan hanya menempatkan dua tabel di klausa kolom atau klausa where dari konstruksi select(). Sekarang kita menggunakan metode join() dan outerjoin(). Metode join() mengembalikan objek gabungan dari satu objek tabel ke objek lainnya. join ( right , onclause = None , isouter = False , full = False ) Fungsi dari parameter yang disebutkan dalam kode di atas adalah sebagai berikut Fungsi dari parameter yang disebutkan dalam kode di atas adalah sebagai berikut right \u2212 sisi kanan sambungan; ini adalah objek Tabel apa pun onclause \u2212 ekspresi SQL yang mewakili klausa ON dari gabungan. Jika dibiarkan di Tidak ada, ia mencoba menggabungkan dua tabel berdasarkan hubungan kunci asing isouter \u2212 jika True, membuat LEFT OUTER JOIN, bukan JOIN full - jika True, membuat FULL OUTER JOIN, bukan LEFT OUTER JOIN Misalnya, penggunaan metode join() berikut akan secara otomatis menghasilkan join berdasarkan kunci asing. >>> print ( students . join ( addresses )) Ini setara dengan mengikuti ekspresi SQL students JOIN addresses ON students . id = addresses . st_id Anda dapat secara eksplisit menyebutkan kriteria bergabung sebagai berikut j = students . join ( addresses , students . c . id == addresses . c . st_id ) Jika kita sekarang membuat konstruk pilih di bawah menggunakan gabungan ini sebagai stmt = select ([ students ]) . select_from ( j ) Ini akan menghasilkan ekspresi SQL berikut SELECT students . id , students . name , students . lastname FROM students JOIN addresses ON students . id = addresses . st_id Jika pernyataan ini dijalankan menggunakan koneksi yang mewakili mesin, data milik kolom yang dipilih akan ditampilkan. Kode lengkapnya adalah sebagai berikut Jika pernyataan ini dijalankan menggunakan koneksi yang mewakili mesin , data milik kolom yang dipilih akan ditampilkan . Kode lengkapnya adalah sebagai berikut from sqlalchemy import create_engine , MetaData , Table , Column , Integer , String , ForeignKey engine = create_engine ( 'sqlite:///college.db' , echo = True ) meta = MetaData () conn = engine . connect () students = Table ( 'students' , meta , Column ( 'id' , Integer , primary_key = True ), Column ( 'name' , String ), Column ( 'lastname' , String ), ) addresses = Table ( 'addresses' , meta , Column ( 'id' , Integer , primary_key = True ), Column ( 'st_id' , Integer , ForeignKey ( 'students.id' )), Column ( 'postal_add' , String ), Column ( 'email_add' , String ) ) from sqlalchemy import join from sqlalchemy.sql import select j = students . join ( addresses , students . c . id == addresses . c . st_id ) stmt = select ([ students ]) . select_from ( j ) result = conn . execute ( stmt ) for row in result : print ( row ) output (1, 'Bob', 'Chrismansyah') (1, 'Bob', 'Chrismansyah') (3, 'Ahmad', 'Haidir')","title":"Using Joins"},{"location":"docs/Using-Joins/#menggunakan-joins","text":"Dalam bab ini, kita akan mempelajari cara menggunakan Gabungan di SQLAlchemy. Efek penggabungan dicapai dengan hanya menempatkan dua tabel di klausa kolom atau klausa where dari konstruksi select(). Sekarang kita menggunakan metode join() dan outerjoin(). Metode join() mengembalikan objek gabungan dari satu objek tabel ke objek lainnya. join ( right , onclause = None , isouter = False , full = False ) Fungsi dari parameter yang disebutkan dalam kode di atas adalah sebagai berikut Fungsi dari parameter yang disebutkan dalam kode di atas adalah sebagai berikut right \u2212 sisi kanan sambungan; ini adalah objek Tabel apa pun onclause \u2212 ekspresi SQL yang mewakili klausa ON dari gabungan. Jika dibiarkan di Tidak ada, ia mencoba menggabungkan dua tabel berdasarkan hubungan kunci asing isouter \u2212 jika True, membuat LEFT OUTER JOIN, bukan JOIN full - jika True, membuat FULL OUTER JOIN, bukan LEFT OUTER JOIN Misalnya, penggunaan metode join() berikut akan secara otomatis menghasilkan join berdasarkan kunci asing. >>> print ( students . join ( addresses )) Ini setara dengan mengikuti ekspresi SQL students JOIN addresses ON students . id = addresses . st_id Anda dapat secara eksplisit menyebutkan kriteria bergabung sebagai berikut j = students . join ( addresses , students . c . id == addresses . c . st_id ) Jika kita sekarang membuat konstruk pilih di bawah menggunakan gabungan ini sebagai stmt = select ([ students ]) . select_from ( j ) Ini akan menghasilkan ekspresi SQL berikut SELECT students . id , students . name , students . lastname FROM students JOIN addresses ON students . id = addresses . st_id Jika pernyataan ini dijalankan menggunakan koneksi yang mewakili mesin, data milik kolom yang dipilih akan ditampilkan. Kode lengkapnya adalah sebagai berikut Jika pernyataan ini dijalankan menggunakan koneksi yang mewakili mesin , data milik kolom yang dipilih akan ditampilkan . Kode lengkapnya adalah sebagai berikut from sqlalchemy import create_engine , MetaData , Table , Column , Integer , String , ForeignKey engine = create_engine ( 'sqlite:///college.db' , echo = True ) meta = MetaData () conn = engine . connect () students = Table ( 'students' , meta , Column ( 'id' , Integer , primary_key = True ), Column ( 'name' , String ), Column ( 'lastname' , String ), ) addresses = Table ( 'addresses' , meta , Column ( 'id' , Integer , primary_key = True ), Column ( 'st_id' , Integer , ForeignKey ( 'students.id' )), Column ( 'postal_add' , String ), Column ( 'email_add' , String ) ) from sqlalchemy import join from sqlalchemy.sql import select j = students . join ( addresses , students . c . id == addresses . c . st_id ) stmt = select ([ students ]) . select_from ( j ) result = conn . execute ( stmt ) for row in result : print ( row ) output (1, 'Bob', 'Chrismansyah') (1, 'Bob', 'Chrismansyah') (3, 'Ahmad', 'Haidir')","title":"Menggunakan Joins"},{"location":"docs/Using-Multiple-Tables/","text":"Menggunakan Banyak Tabel \u00b6 Salah satu fitur penting RDBMS adalah membangun hubungan antar tabel. Operasi SQL seperti SELECT, UPDATE dan DELETE dapat dilakukan pada tabel terkait. Bagian ini menjelaskan operasi ini menggunakan SQLAlchemy. Untuk tujuan ini, dua tabel dibuat di database SQLite kami (college.db). Tabel siswa memiliki struktur yang sama seperti yang diberikan pada bagian sebelumnya; sedangkan tabel alamat memiliki kolom st_id yang dipetakan ke kolom id pada tabel siswa menggunakan batasan kunci asing. Kode berikut akan membuat dua tabel di college.db from sqlalchemy import create_engine , MetaData , Table , Column , Integer , String , ForeignKey engine = create_engine ( 'sqlite:///college.db' , echo = True ) meta = MetaData () students = Table ( 'students' , meta , Column ( 'id' , Integer , primary_key = True ), Column ( 'name' , String ), Column ( 'lastname' , String ), ) addresses = Table ( 'addresses' , meta , Column ( 'id' , Integer , primary_key = True ), Column ( 'st_id' , Integer , ForeignKey ( 'students.id' )), Column ( 'postal_add' , String ), Column ( 'email_add' , String )) meta . create_all ( engine ) Output: INFO sqlalchemy.engine.Engine SELECT students.id, students.name, students.lastname FROM students 2022-11-20 00:23:20,572 INFO sqlalchemy.engine.Engine [generated in 0.00054s] () st_id INTEGER, postal_add VARCHAR, email_add VARCHAR, PRIMARY KEY (id), FOREIGN KEY(st_id) REFERENCES students (id) ) Kode di atas akan diterjemahkan menjadi kueri CREATE TABLE untuk siswa dan tabel alamat seperti di bawah ini CREATE TABLE students ( id INTEGER NOT NULL , name VARCHAR , lastname VARCHAR , PRIMARY KEY ( id ) ) CREATE TABLE addresses ( id INTEGER NOT NULL , st_id INTEGER , postal_add VARCHAR , email_add VARCHAR , PRIMARY KEY ( id ), FOREIGN KEY ( st_id ) REFERENCES students ( id ) ) Tabel ini diisi dengan data dengan mengeksekusi metode insert() dari objek tabel. Untuk menyisipkan 4 baris pada tabel siswa, Anda dapat menggunakan kode di bawah ini conn . execute ( students . insert (), [ { 'name' : '' , 'lastname' : '' }, { 'name' : 'Bob' , 'lastname' : 'Chrismansyah' }, { 'name' : 'Ariandini' , 'lastname' : 'Aulia' }, { 'name' : 'Ahmad' , 'lastname' : 'Haidir' }, ]) Baris ditambahkan dalam tabel alamat dengan bantuan kode berikut addresses = Table ( 'addresses' , meta , Column ( 'id' , Integer , primary_key = True ), Column ( 'st_id' , Integer ), Column ( 'postal_add' , String ), Column ( 'email_add' , String ) ) conn . execute ( addresses . insert (), [ { 'st_id' : 1 , 'postal_add' : 'Pk 4' , 'email_add' : 'bob@ilkom.my.id' }, { 'st_id' : 1 , 'postal_add' : 'PK 5' , 'email_add' : 'ariandini@gmail.com' }, { 'st_id' : 3 , 'postal_add' : 'Pk 6' , 'email_add' : 'haidir757@gmail.com' }, ]) Output: 2022-11-20 01:10:14,982 INFO sqlalchemy.engine.Engine INSERT INTO addresses (st_id, postal_add, email_add) VALUES (?, ?, ?) 2022-11-20 01:10:14,982 INFO sqlalchemy.engine.Engine [generated in 0.00042s] ((1, 'Pk 4', 'bob@ilkom.my.id'), (1, 'PK 5', 'ariandini@gmail.com'), (3, 'Pk 6', 'haidir757@gmail.com')) 2022-11-20 01:10:14,983 INFO sqlalchemy.engine.Engine COMMIT Perhatikan bahwa kolom st_id di tabel alamat merujuk ke kolom id di tabel siswa. Kita sekarang dapat menggunakan relasi ini untuk mengambil data dari kedua tabel. Kami ingin mengambil nama dan nama belakang dari tabel siswa yang sesuai dengan st_id di tabel alamat. from sqlalchemy.sql import select s = select ([ students , addresses ]) . where ( students . c . id == addresses . c . st_id ) result = conn . execute ( s ) for row in result : print ( row ) Output: (1, 'Bob', 'Chrismansyah', 1, 1, 'Pk 4', 'bob@ilkom.my.id') (1, 'Bob', 'Chrismansyah', 2, 1, 'PK 5', 'ariandini@gmail.com') (3, 'Ahmad', 'Haidir', 3, 3, 'Pk 6', 'haidir757@gmail.com') Objek yang dipilih akan secara efektif diterjemahkan ke dalam ekspresi SQL berikut yang menggabungkan dua tabel pada relasi umum SELECT students . id , students . name , students . lastname , addresses . id , addresses . st_id , addresses . postal_add , addresses . email_add FROM students , addresses WHERE students . id = addresses . st_id","title":"Index"},{"location":"docs/Using-Multiple-Tables/#menggunakan-banyak-tabel","text":"Salah satu fitur penting RDBMS adalah membangun hubungan antar tabel. Operasi SQL seperti SELECT, UPDATE dan DELETE dapat dilakukan pada tabel terkait. Bagian ini menjelaskan operasi ini menggunakan SQLAlchemy. Untuk tujuan ini, dua tabel dibuat di database SQLite kami (college.db). Tabel siswa memiliki struktur yang sama seperti yang diberikan pada bagian sebelumnya; sedangkan tabel alamat memiliki kolom st_id yang dipetakan ke kolom id pada tabel siswa menggunakan batasan kunci asing. Kode berikut akan membuat dua tabel di college.db from sqlalchemy import create_engine , MetaData , Table , Column , Integer , String , ForeignKey engine = create_engine ( 'sqlite:///college.db' , echo = True ) meta = MetaData () students = Table ( 'students' , meta , Column ( 'id' , Integer , primary_key = True ), Column ( 'name' , String ), Column ( 'lastname' , String ), ) addresses = Table ( 'addresses' , meta , Column ( 'id' , Integer , primary_key = True ), Column ( 'st_id' , Integer , ForeignKey ( 'students.id' )), Column ( 'postal_add' , String ), Column ( 'email_add' , String )) meta . create_all ( engine ) Output: INFO sqlalchemy.engine.Engine SELECT students.id, students.name, students.lastname FROM students 2022-11-20 00:23:20,572 INFO sqlalchemy.engine.Engine [generated in 0.00054s] () st_id INTEGER, postal_add VARCHAR, email_add VARCHAR, PRIMARY KEY (id), FOREIGN KEY(st_id) REFERENCES students (id) ) Kode di atas akan diterjemahkan menjadi kueri CREATE TABLE untuk siswa dan tabel alamat seperti di bawah ini CREATE TABLE students ( id INTEGER NOT NULL , name VARCHAR , lastname VARCHAR , PRIMARY KEY ( id ) ) CREATE TABLE addresses ( id INTEGER NOT NULL , st_id INTEGER , postal_add VARCHAR , email_add VARCHAR , PRIMARY KEY ( id ), FOREIGN KEY ( st_id ) REFERENCES students ( id ) ) Tabel ini diisi dengan data dengan mengeksekusi metode insert() dari objek tabel. Untuk menyisipkan 4 baris pada tabel siswa, Anda dapat menggunakan kode di bawah ini conn . execute ( students . insert (), [ { 'name' : '' , 'lastname' : '' }, { 'name' : 'Bob' , 'lastname' : 'Chrismansyah' }, { 'name' : 'Ariandini' , 'lastname' : 'Aulia' }, { 'name' : 'Ahmad' , 'lastname' : 'Haidir' }, ]) Baris ditambahkan dalam tabel alamat dengan bantuan kode berikut addresses = Table ( 'addresses' , meta , Column ( 'id' , Integer , primary_key = True ), Column ( 'st_id' , Integer ), Column ( 'postal_add' , String ), Column ( 'email_add' , String ) ) conn . execute ( addresses . insert (), [ { 'st_id' : 1 , 'postal_add' : 'Pk 4' , 'email_add' : 'bob@ilkom.my.id' }, { 'st_id' : 1 , 'postal_add' : 'PK 5' , 'email_add' : 'ariandini@gmail.com' }, { 'st_id' : 3 , 'postal_add' : 'Pk 6' , 'email_add' : 'haidir757@gmail.com' }, ]) Output: 2022-11-20 01:10:14,982 INFO sqlalchemy.engine.Engine INSERT INTO addresses (st_id, postal_add, email_add) VALUES (?, ?, ?) 2022-11-20 01:10:14,982 INFO sqlalchemy.engine.Engine [generated in 0.00042s] ((1, 'Pk 4', 'bob@ilkom.my.id'), (1, 'PK 5', 'ariandini@gmail.com'), (3, 'Pk 6', 'haidir757@gmail.com')) 2022-11-20 01:10:14,983 INFO sqlalchemy.engine.Engine COMMIT Perhatikan bahwa kolom st_id di tabel alamat merujuk ke kolom id di tabel siswa. Kita sekarang dapat menggunakan relasi ini untuk mengambil data dari kedua tabel. Kami ingin mengambil nama dan nama belakang dari tabel siswa yang sesuai dengan st_id di tabel alamat. from sqlalchemy.sql import select s = select ([ students , addresses ]) . where ( students . c . id == addresses . c . st_id ) result = conn . execute ( s ) for row in result : print ( row ) Output: (1, 'Bob', 'Chrismansyah', 1, 1, 'Pk 4', 'bob@ilkom.my.id') (1, 'Bob', 'Chrismansyah', 2, 1, 'PK 5', 'ariandini@gmail.com') (3, 'Ahmad', 'Haidir', 3, 3, 'Pk 6', 'haidir757@gmail.com') Objek yang dipilih akan secara efektif diterjemahkan ke dalam ekspresi SQL berikut yang menggabungkan dua tabel pada relasi umum SELECT students . id , students . name , students . lastname , addresses . id , addresses . st_id , addresses . postal_add , addresses . email_add FROM students , addresses WHERE students . id = addresses . st_id","title":"Menggunakan Banyak Tabel"},{"location":"docs/Using-Textual-SQL/","text":"SQL Textual \u00b6 SQLAlchemy memungkinkan Anda hanya menggunakan string, untuk kasus-kasus ketika SQL sudah dikenal dan tidak ada kebutuhan yang kuat untuk pernyataan untuk mendukung fitur dinamis. Konstruksi text() digunakan untuk menyusun pernyataan tekstual yang diteruskan ke database yang sebagian besar tidak berubah. Itu membangun TextClause baru , yang mewakili string SQL tekstual secara langsung seperti yang ditunjukkan pada kode di bawah ini from sqlalchemy import text t = text ( \"SELECT * FROM students\" ) result = connection . execute ( t ) Keuntungan yang disediankan text() adalah: dukungan backend-netral untuk mengikat parameter opsi eksekusi per-pernyataan perilaku mengetik hasil-kolom Menggunakan parameter terikat \u00b6 Fungsi text() membutuhkan parameter Bound dalam format titik dua bernama. Mereka konsisten terlepas dari backend database. Untuk mengirim nilai untuk parameter, kami meneruskannya ke metode execution() sebagai argumen tambahan. Contoh berikut menggunakan parameter terikat dalam SQL tekstual from sqlalchemy.sql import text s = text ( \"select students.name, students.lastname from students where students.name between :x and :y\" ) conn . execute ( s , x = 'A' , y = 'L' ) . fetchall () Jika dijalankan, hasilnya sebagai berikut Fungsi text() membuat ekspresi SQL sebagai berikut: select students . name , students . lastname from students where students . name between ? and ? Nilai x = 'A' dan y = 'L' dilewatkan sebagai parameter. Hasilnya adalah daftar baris dengan nama antara 'A' dan 'L' ( 'Ahmad' , 'Haidir' )( 'Bob' , 'Chrismansayah' )( 'Ariandini' , 'Aulia' ) Konstruksi text() mendukung nilai terikat yang telah ditetapkan sebelumnya menggunakan metode TextClause.bindparams() . Parameter juga dapat diketik secara eksplisit sebagai berikut stmt = text ( \"SELECT * FROM students WHERE students.name BETWEEN :x AND :y\" ) stmt = stmt . bindparams ( bindparam ( \"x\" , type_ = String ), bindparam ( \"y\" , type_ = String ) ) result = conn . execute ( stmt , { \"x\" : \"A\" , \"y\" : \"L\" }) # The text() function also be produces fragments of SQL within a select() object that # accepts text() objects as an arguments. The \u201cgeometry\u201d of the statement is provided by # select() construct , and the textual content by text() construct. We can build a statement # without the need to refer to any pre-established Table metadata. from sqlalchemy.sql import select s = select ([ text ( \"students.name, students.lastname from students\" )]) . where ( text ( \"students.name between :x and :y\" )) conn . execute ( s , x = 'A' , y = 'L' ) . fetchall () Anda juga dapat menggunakan fungsi and_() untuk menggabungkan beberapa kondisi dalam klausa WHERE yang dibuat dengan bantuan fungsi text(). from sqlalchemy import and_ from sqlalchemy.sql import select s = select ([ text ( \"* from students\" )]) \\ . where ( and_ ( text ( \"students.name between :x and :y\" ), text ( \"students.id>2\" ) ) ) conn . execute ( s , x = 'A' , y = 'L' ) . fetchall () Kode di atas mengambil baris dengan nama antara \"A\" dan \"L\" dengan id lebih besar dari 2. Keluaran kode diberikan di bawah ini -","title":"Using Textual SQL"},{"location":"docs/Using-Textual-SQL/#sql-textual","text":"SQLAlchemy memungkinkan Anda hanya menggunakan string, untuk kasus-kasus ketika SQL sudah dikenal dan tidak ada kebutuhan yang kuat untuk pernyataan untuk mendukung fitur dinamis. Konstruksi text() digunakan untuk menyusun pernyataan tekstual yang diteruskan ke database yang sebagian besar tidak berubah. Itu membangun TextClause baru , yang mewakili string SQL tekstual secara langsung seperti yang ditunjukkan pada kode di bawah ini from sqlalchemy import text t = text ( \"SELECT * FROM students\" ) result = connection . execute ( t ) Keuntungan yang disediankan text() adalah: dukungan backend-netral untuk mengikat parameter opsi eksekusi per-pernyataan perilaku mengetik hasil-kolom","title":"SQL Textual"},{"location":"docs/Using-Textual-SQL/#menggunakan-parameter-terikat","text":"Fungsi text() membutuhkan parameter Bound dalam format titik dua bernama. Mereka konsisten terlepas dari backend database. Untuk mengirim nilai untuk parameter, kami meneruskannya ke metode execution() sebagai argumen tambahan. Contoh berikut menggunakan parameter terikat dalam SQL tekstual from sqlalchemy.sql import text s = text ( \"select students.name, students.lastname from students where students.name between :x and :y\" ) conn . execute ( s , x = 'A' , y = 'L' ) . fetchall () Jika dijalankan, hasilnya sebagai berikut Fungsi text() membuat ekspresi SQL sebagai berikut: select students . name , students . lastname from students where students . name between ? and ? Nilai x = 'A' dan y = 'L' dilewatkan sebagai parameter. Hasilnya adalah daftar baris dengan nama antara 'A' dan 'L' ( 'Ahmad' , 'Haidir' )( 'Bob' , 'Chrismansayah' )( 'Ariandini' , 'Aulia' ) Konstruksi text() mendukung nilai terikat yang telah ditetapkan sebelumnya menggunakan metode TextClause.bindparams() . Parameter juga dapat diketik secara eksplisit sebagai berikut stmt = text ( \"SELECT * FROM students WHERE students.name BETWEEN :x AND :y\" ) stmt = stmt . bindparams ( bindparam ( \"x\" , type_ = String ), bindparam ( \"y\" , type_ = String ) ) result = conn . execute ( stmt , { \"x\" : \"A\" , \"y\" : \"L\" }) # The text() function also be produces fragments of SQL within a select() object that # accepts text() objects as an arguments. The \u201cgeometry\u201d of the statement is provided by # select() construct , and the textual content by text() construct. We can build a statement # without the need to refer to any pre-established Table metadata. from sqlalchemy.sql import select s = select ([ text ( \"students.name, students.lastname from students\" )]) . where ( text ( \"students.name between :x and :y\" )) conn . execute ( s , x = 'A' , y = 'L' ) . fetchall () Anda juga dapat menggunakan fungsi and_() untuk menggabungkan beberapa kondisi dalam klausa WHERE yang dibuat dengan bantuan fungsi text(). from sqlalchemy import and_ from sqlalchemy.sql import select s = select ([ text ( \"* from students\" )]) \\ . where ( and_ ( text ( \"students.name between :x and :y\" ), text ( \"students.id>2\" ) ) ) conn . execute ( s , x = 'A' , y = 'L' ) . fetchall () Kode di atas mengambil baris dengan nama antara \"A\" dan \"L\" dengan id lebih besar dari 2. Keluaran kode diberikan di bawah ini -","title":"Menggunakan parameter terikat"}]}
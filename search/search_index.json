{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Tugas Teknologi Basis Data \u00b6 Dokumentasi ini dibuat dari hasil translate dari website https://www.tutorialspoint.com/sqlalchemy/index.htm Silahkan klik website tersebut untuk melihat dokumentasi aslinya. Terima Kasih \u00b6","title":"Docs"},{"location":"#tugas-teknologi-basis-data","text":"Dokumentasi ini dibuat dari hasil translate dari website https://www.tutorialspoint.com/sqlalchemy/index.htm Silahkan klik website tersebut untuk melihat dokumentasi aslinya.","title":"Tugas Teknologi Basis Data"},{"location":"#terima-kasih","text":"","title":"Terima Kasih"},{"location":"about/","text":"","title":"About"},{"location":"docs/Connecting-to-Database/","text":"Menghubungkan ke database \u00b6 Pada materi sebelumnya, kita telah membahas tentang bahasa ekspresi di SQLAlchemy. Sekarang mari kita lanjutkan ke langkah-langkah yang dibutuhkan dalam menghubungkan ke database. Kelas mesin menghubungkan Pool dan Dialect bersama -sama untuk menyediakan sumber konektivitas dan perilaku database. Objek kelas Engine dibuat instance-nya menggunakan fungsi create_engine(). Fungsi create_engine() mengambil database sebagai satu argumen. Basis data tidak perlu didefinisikan di mana pun. Formulir pemanggilan standar harus mengirim URL sebagai argumen posisi pertama, biasanya berupa string yang menunjukkan dialek database dan argumen koneksi. Menggunakan kode yang diberikan di bawah ini, kita dapat membuat database. >>> from sqlalchemy import create_engine >>> engine = create_engine ( 'sqlite:///college.db' , echo = True ) Untuk database MySQL , gunakan perintah di bawah ini engine = create_engine ( \"mysql://user:pwd@localhost/college\" , echo = True ) Untuk secara khusus menyebutkan DB-API yang akan digunakan untuk koneksi, string URL berbentuk sebagai berikut dialect [ + driver ]: // user : password @ host / dbname Misalnya, jika Anda menggunakan driver PyMySQL dengan MySQL , gunakan perintah berikut mysql + pymysql : //< username > : < password >@< host >/< dbname > Echo Flasgs adalah shortcut untuk menyiapkan logging SQLAlchemy, yang dilakukan melalui modul logging standar Python. Pada bab selanjutnya, kita akan mempelajari semua SQL yang dihasilkan. Untuk menyembunyikan output verbose, setel atribut echo ke None. Argumen lain untuk fungsi create_engine() mungkin khusus untuk dialek. No Metode & Deskripsi 1 connect() Return koneksi object 2 execute() Mengeksekusi konstruksi pernyataan SQL 3 begin() Mengembalikan konteks manager yang mengirimkan koneksi dengan transaksi yang dibuat 4 dispose() Membuang kumpulan koneksi yang digunakan oleh Engine 5 driver() Nama driver yang digunakan oleh Engine 6 table_name() Mengembalikan daftar semua nama tabel yang tersedia di database 7 transaction() Mengeksekusi fungsi yang diberikan dalam batas transaksi","title":"Connecting to Database"},{"location":"docs/Connecting-to-Database/#menghubungkan-ke-database","text":"Pada materi sebelumnya, kita telah membahas tentang bahasa ekspresi di SQLAlchemy. Sekarang mari kita lanjutkan ke langkah-langkah yang dibutuhkan dalam menghubungkan ke database. Kelas mesin menghubungkan Pool dan Dialect bersama -sama untuk menyediakan sumber konektivitas dan perilaku database. Objek kelas Engine dibuat instance-nya menggunakan fungsi create_engine(). Fungsi create_engine() mengambil database sebagai satu argumen. Basis data tidak perlu didefinisikan di mana pun. Formulir pemanggilan standar harus mengirim URL sebagai argumen posisi pertama, biasanya berupa string yang menunjukkan dialek database dan argumen koneksi. Menggunakan kode yang diberikan di bawah ini, kita dapat membuat database. >>> from sqlalchemy import create_engine >>> engine = create_engine ( 'sqlite:///college.db' , echo = True ) Untuk database MySQL , gunakan perintah di bawah ini engine = create_engine ( \"mysql://user:pwd@localhost/college\" , echo = True ) Untuk secara khusus menyebutkan DB-API yang akan digunakan untuk koneksi, string URL berbentuk sebagai berikut dialect [ + driver ]: // user : password @ host / dbname Misalnya, jika Anda menggunakan driver PyMySQL dengan MySQL , gunakan perintah berikut mysql + pymysql : //< username > : < password >@< host >/< dbname > Echo Flasgs adalah shortcut untuk menyiapkan logging SQLAlchemy, yang dilakukan melalui modul logging standar Python. Pada bab selanjutnya, kita akan mempelajari semua SQL yang dihasilkan. Untuk menyembunyikan output verbose, setel atribut echo ke None. Argumen lain untuk fungsi create_engine() mungkin khusus untuk dialek. No Metode & Deskripsi 1 connect() Return koneksi object 2 execute() Mengeksekusi konstruksi pernyataan SQL 3 begin() Mengembalikan konteks manager yang mengirimkan koneksi dengan transaksi yang dibuat 4 dispose() Membuang kumpulan koneksi yang digunakan oleh Engine 5 driver() Nama driver yang digunakan oleh Engine 6 table_name() Mengembalikan daftar semua nama tabel yang tersedia di database 7 transaction() Mengeksekusi fungsi yang diberikan dalam batas transaksi","title":"Menghubungkan ke database"},{"location":"docs/Creating-Table/","text":"Membuat Tabel \u00b6 SQL menyusun ekspresinya terhadap kolom tabel. Objek SQLAlchemy Column mewakili kolom dalam tabel database yang pada gilirannya diwakili oleh Tableobject. Metadata berisi definisi tabel dan objek terkait seperti indeks, tampilan, triggers, dll. Karena objek kelas MetaData dari SQLAlchemy Metadata adalah kumpulan objek Tabel dan konstruksi skema yang terkait. Ini menampung kumpulan objek Tabel serta pengikatan opsional ke Mesin atau Koneksi. from sqlalchemy import MetaData meta = MetaData () Konstruktor kelas MetaData dapat memiliki parameter bind dan skema yang secara default adalah None. Selanjutnya, kita mendefinisikan tabel kita semua di dalam katalog metadata di atas, menggunakan Table construct , yang menyerupai pernyataan SQL CREATE TABLE biasa. Objek kelas Tabel mewakili tabel yang sesuai dalam database. Konstruktor mengambil parameter berikut Nama Nama tabel metadata Objek MetaData yang akan mengandung tabel ini Kolom Satu atau lebih objek kelas kolom Objek kolom mewakili kolom dalam tabel database. Konstruktor mengambil nama, tipe, dan parameter lain seperti primary_key, autoincrement, dan batasan lainnya. SQLAlchemy mencocokkan data Python dengan tipe data kolom generik terbaik yang ditentukan di dalamnya. Beberapa tipe data umum adalah: BigInteger Boolean Date DateTime Float Integer Numeric SmallInteger Sting Text Time Untuk membuat tabel siswa di database perguruan tinggi, gunakan potongan berikut: from sqlalchemy import Table , Column , Integer , String , MetaData meta = MetaData () students = Table ( 'students' , meta , Column ( 'id' , Integer , primary_key = True ), Column ( 'name' , String ), Column ( 'lastname' , String ), ) Fungsi create_all() menggunakan objek mesin untuk membuat semua objek tabel yang ditentukan dan menyimpan informasi dalam metadata. meta . create_all ( engine ) Kode lengkap diberikan di bawah ini yang akan membuat database SQLite college.db dengan tabel siswa di dalamnya. Karena echo atribut dari fungsi create_engine() disetel ke True, konsol akan menampilkan kueri SQL aktual untuk pembuatan tabel sebagai berikut: college.db akan dibuat di direktori kerja saat ini. Untuk memeriksa apakah tabel siswa sudah dibuat, Anda dapat membuka database menggunakan alat GUI SQLite seperti SQLiteStudio","title":"Creating Table"},{"location":"docs/Creating-Table/#membuat-tabel","text":"SQL menyusun ekspresinya terhadap kolom tabel. Objek SQLAlchemy Column mewakili kolom dalam tabel database yang pada gilirannya diwakili oleh Tableobject. Metadata berisi definisi tabel dan objek terkait seperti indeks, tampilan, triggers, dll. Karena objek kelas MetaData dari SQLAlchemy Metadata adalah kumpulan objek Tabel dan konstruksi skema yang terkait. Ini menampung kumpulan objek Tabel serta pengikatan opsional ke Mesin atau Koneksi. from sqlalchemy import MetaData meta = MetaData () Konstruktor kelas MetaData dapat memiliki parameter bind dan skema yang secara default adalah None. Selanjutnya, kita mendefinisikan tabel kita semua di dalam katalog metadata di atas, menggunakan Table construct , yang menyerupai pernyataan SQL CREATE TABLE biasa. Objek kelas Tabel mewakili tabel yang sesuai dalam database. Konstruktor mengambil parameter berikut Nama Nama tabel metadata Objek MetaData yang akan mengandung tabel ini Kolom Satu atau lebih objek kelas kolom Objek kolom mewakili kolom dalam tabel database. Konstruktor mengambil nama, tipe, dan parameter lain seperti primary_key, autoincrement, dan batasan lainnya. SQLAlchemy mencocokkan data Python dengan tipe data kolom generik terbaik yang ditentukan di dalamnya. Beberapa tipe data umum adalah: BigInteger Boolean Date DateTime Float Integer Numeric SmallInteger Sting Text Time Untuk membuat tabel siswa di database perguruan tinggi, gunakan potongan berikut: from sqlalchemy import Table , Column , Integer , String , MetaData meta = MetaData () students = Table ( 'students' , meta , Column ( 'id' , Integer , primary_key = True ), Column ( 'name' , String ), Column ( 'lastname' , String ), ) Fungsi create_all() menggunakan objek mesin untuk membuat semua objek tabel yang ditentukan dan menyimpan informasi dalam metadata. meta . create_all ( engine ) Kode lengkap diberikan di bawah ini yang akan membuat database SQLite college.db dengan tabel siswa di dalamnya. Karena echo atribut dari fungsi create_engine() disetel ke True, konsol akan menampilkan kueri SQL aktual untuk pembuatan tabel sebagai berikut: college.db akan dibuat di direktori kerja saat ini. Untuk memeriksa apakah tabel siswa sudah dibuat, Anda dapat membuka database menggunakan alat GUI SQLite seperti SQLiteStudio","title":"Membuat Tabel"},{"location":"docs/Executing-Expression/","text":"Mengeksekusi \u00b6 Untuk mengeksekusi ekspresi SQL yang dihasilkan, kita harus mendapatkan objek koneksi yang mewakili sumber daya koneksi DBAPI yang diperiksa secara aktif dan kemudian memberi makan objek ekspresi seperti yang ditunjukkan pada kode di bawah ini. conn = engine . connect () Objek insert() berikut dapat digunakan untuk metode execution() ins = students . insert () . values ( name = 'Bob' , lastname = 'Chrismansyah' ) result = conn . execute ( ins ) Konsol menunjukkan hasil eksekusi ekspresi SQL seperti di bawah ini INSERT INTO students ( name , lastname ) VALUES ( ? , ? ) ( 'Bob' , 'Chrismansyah' ) COMMIT Berikut ini adalah keseluruhan cuplikan yang menunjukkan eksekusi query INSERT menggunakan teknik inti SQLAlchemy from sqlalchemy import create_engine , MetaData , Table , Column , Integer , String engine = create_engine ( 'sqlite:///college.db' , echo = True ) meta = MetaData () students = Table ( 'students' , meta , Column ( 'id' , Integer , primary_key = True ), Column ( 'name' , String ), Column ( 'lastname' , String ), ) ins = students . insert () # ins = students.insert().values(name = 'Bob', lastname = 'Chrismansayah') ins = students . insert () . values ( name = 'Ariandini' , lastname = 'Aulia' ) # ins = students.insert().values(name = 'Haidir', lastname = 'Haidir') # insert data dieksekusi hanya satu per satu, tidak bisa 3 sekaligus result = conn . execute ( ins ) Hasilnya dapat diverifikasi dengan membuka database menggunakan SQLite Studio seperti yang ditunjukkan pada tangkapan layar di bawah ini Variabel hasil dikenal sebagai objek ResultProxy . Ini analog dengan objek kursor DBAPI. Kami dapat memperoleh informasi tentang nilai kunci utama yang dihasilkan dari pernyataan kami menggunakan ResultProxy.inserted_primary_key seperti yang ditunjukkan di bawah ini result . inserted_primary_key [ 1 ] Untuk mengeluarkan banyak sisipan menggunakan metode execution many() DBAPI, kita dapat mengirimkan daftar kamus yang masing-masing berisi kumpulan parameter yang berbeda untuk disisipkan. conn . execute ( students . insert (), [ { 'name' : 'Bob' , 'lastname' : 'Langau' }, { 'name' : 'Aiandini' , 'lastname' : 'Dini' }, { 'name' : 'Haidir' , 'lastname' : 'Ahmed' }, { 'name' : 'Masuk' , 'lastname' : 'Saja' }, ])","title":"Executing Language"},{"location":"docs/Executing-Expression/#mengeksekusi","text":"Untuk mengeksekusi ekspresi SQL yang dihasilkan, kita harus mendapatkan objek koneksi yang mewakili sumber daya koneksi DBAPI yang diperiksa secara aktif dan kemudian memberi makan objek ekspresi seperti yang ditunjukkan pada kode di bawah ini. conn = engine . connect () Objek insert() berikut dapat digunakan untuk metode execution() ins = students . insert () . values ( name = 'Bob' , lastname = 'Chrismansyah' ) result = conn . execute ( ins ) Konsol menunjukkan hasil eksekusi ekspresi SQL seperti di bawah ini INSERT INTO students ( name , lastname ) VALUES ( ? , ? ) ( 'Bob' , 'Chrismansyah' ) COMMIT Berikut ini adalah keseluruhan cuplikan yang menunjukkan eksekusi query INSERT menggunakan teknik inti SQLAlchemy from sqlalchemy import create_engine , MetaData , Table , Column , Integer , String engine = create_engine ( 'sqlite:///college.db' , echo = True ) meta = MetaData () students = Table ( 'students' , meta , Column ( 'id' , Integer , primary_key = True ), Column ( 'name' , String ), Column ( 'lastname' , String ), ) ins = students . insert () # ins = students.insert().values(name = 'Bob', lastname = 'Chrismansayah') ins = students . insert () . values ( name = 'Ariandini' , lastname = 'Aulia' ) # ins = students.insert().values(name = 'Haidir', lastname = 'Haidir') # insert data dieksekusi hanya satu per satu, tidak bisa 3 sekaligus result = conn . execute ( ins ) Hasilnya dapat diverifikasi dengan membuka database menggunakan SQLite Studio seperti yang ditunjukkan pada tangkapan layar di bawah ini Variabel hasil dikenal sebagai objek ResultProxy . Ini analog dengan objek kursor DBAPI. Kami dapat memperoleh informasi tentang nilai kunci utama yang dihasilkan dari pernyataan kami menggunakan ResultProxy.inserted_primary_key seperti yang ditunjukkan di bawah ini result . inserted_primary_key [ 1 ] Untuk mengeluarkan banyak sisipan menggunakan metode execution many() DBAPI, kita dapat mengirimkan daftar kamus yang masing-masing berisi kumpulan parameter yang berbeda untuk disisipkan. conn . execute ( students . insert (), [ { 'name' : 'Bob' , 'lastname' : 'Langau' }, { 'name' : 'Aiandini' , 'lastname' : 'Dini' }, { 'name' : 'Haidir' , 'lastname' : 'Ahmed' }, { 'name' : 'Masuk' , 'lastname' : 'Saja' }, ])","title":"Mengeksekusi"},{"location":"docs/Expression-Language/","text":"Expression Language \u00b6 Inti SQLAlchemy mencakup mesin rendering SQL, integrasi DBAPI, integrasi transaksi , dan layanan deskripsi skema . Inti SQLAlchemy menggunakan SQL Expression Language yang menyediakan paradigma penggunaan yang berpusat pada skema sedangkan SQLAlchemy ORM adalah mode penggunaan yang berpusat pada domain . Bahasa Ekspresi SQL menyajikan sistem yang merepresentasikan struktur dan ekspresi basis data relasional menggunakan konstruksi Python. Ini menyajikan sistem yang mewakili konstruksi primitif dari basis data relasional secara langsung tanpa pendapat, yang berbeda dengan ORM yang menyajikan pola penggunaan tingkat tinggi dan abstrak, yang dengan sendirinya merupakan contoh penggunaan terapan dari Bahasa Ekspresi. Bahasa Ekspresi adalah salah satu komponen inti dari SQLAlchemy. Ini memungkinkan pemrogram untuk menentukan pernyataan SQL dalam kode Python dan menggunakannya secara langsung dalam kueri yang lebih kompleks. Bahasa ekspresi tidak bergantung pada backend dan secara komprehensif mencakup setiap aspek SQL mentah. Ini lebih dekat ke SQL mentah daripada komponen lain di SQLAlchemy. Bahasa Ekspresi mewakili konstruksi primitif dari basis data relasional secara langsung. Karena ORM didasarkan pada bahasa Expression, aplikasi database Python yang khas mungkin memiliki penggunaan keduanya yang tumpang tindih. Aplikasi dapat menggunakan bahasa ekspresi saja, meskipun harus menentukan sistemnya sendiri untuk menerjemahkan konsep aplikasi ke dalam kueri basis data individual. Pernyataan bahasa Ekspresi akan diterjemahkan ke dalam kueri SQL mentah yang sesuai oleh mesin SQLAlchemy. Sekarang kita akan mempelajari cara membuat mesin dan menjalankan berbagai kueri SQL dengan bantuannya.","title":"Expression Language"},{"location":"docs/Expression-Language/#expression-language","text":"Inti SQLAlchemy mencakup mesin rendering SQL, integrasi DBAPI, integrasi transaksi , dan layanan deskripsi skema . Inti SQLAlchemy menggunakan SQL Expression Language yang menyediakan paradigma penggunaan yang berpusat pada skema sedangkan SQLAlchemy ORM adalah mode penggunaan yang berpusat pada domain . Bahasa Ekspresi SQL menyajikan sistem yang merepresentasikan struktur dan ekspresi basis data relasional menggunakan konstruksi Python. Ini menyajikan sistem yang mewakili konstruksi primitif dari basis data relasional secara langsung tanpa pendapat, yang berbeda dengan ORM yang menyajikan pola penggunaan tingkat tinggi dan abstrak, yang dengan sendirinya merupakan contoh penggunaan terapan dari Bahasa Ekspresi. Bahasa Ekspresi adalah salah satu komponen inti dari SQLAlchemy. Ini memungkinkan pemrogram untuk menentukan pernyataan SQL dalam kode Python dan menggunakannya secara langsung dalam kueri yang lebih kompleks. Bahasa ekspresi tidak bergantung pada backend dan secara komprehensif mencakup setiap aspek SQL mentah. Ini lebih dekat ke SQL mentah daripada komponen lain di SQLAlchemy. Bahasa Ekspresi mewakili konstruksi primitif dari basis data relasional secara langsung. Karena ORM didasarkan pada bahasa Expression, aplikasi database Python yang khas mungkin memiliki penggunaan keduanya yang tumpang tindih. Aplikasi dapat menggunakan bahasa ekspresi saja, meskipun harus menentukan sistemnya sendiri untuk menerjemahkan konsep aplikasi ke dalam kueri basis data individual. Pernyataan bahasa Ekspresi akan diterjemahkan ke dalam kueri SQL mentah yang sesuai oleh mesin SQLAlchemy. Sekarang kita akan mempelajari cara membuat mesin dan menjalankan berbagai kueri SQL dengan bantuannya.","title":"Expression Language"},{"location":"docs/SQL-Expressions/","text":"SQL Expression \u00b6 Ekspresi SQL dibangun menggunakan metode yang sesuai relatif terhadap objek tabel target. Misalnya, pernyataan INSERT dibuat dengan mengeksekusi metode insert() sebagai berikut ins = students . insert () Hasil dari metode di atas adalah objek sisipan yang dapat diverifikasi dengan menggunakan fungsi str(). Kode di bawah ini menyisipkan detail seperti id siswa, nama, nama belakang. 'INSERT INTO students (id, name, lastname) VALUES (:id, :name, :lastname)' Dimungkinkan untuk memasukkan nilai dalam bidang tertentu dengan metode values() untuk memasukkan objek. Kode untuk hal yang sama diberikan di bawah ini >>> ins = users . insert () . values ( name = 'Karan' ) >>> str ( ins ) 'INSERT INTO users (name) VALUES (:name)' SQL yang bergema di konsol Python tidak menunjukkan nilai sebenarnya ('Karan' dalam kasus ini). Sebagai gantinya, SQLALchemy menghasilkan parameter bind yang terlihat dalam bentuk pernyataan yang dikompilasi. ins . compile () . params { 'name' : 'Karan' } Demikian pula, metode seperti update(), delete() dan select() masing-masing membuat ekspresi UPDATE, DELETE dan SELECT. Kita akan belajar tentang mereka di bab-bab selanjutnya.","title":"Index"},{"location":"docs/SQL-Expressions/#sql-expression","text":"Ekspresi SQL dibangun menggunakan metode yang sesuai relatif terhadap objek tabel target. Misalnya, pernyataan INSERT dibuat dengan mengeksekusi metode insert() sebagai berikut ins = students . insert () Hasil dari metode di atas adalah objek sisipan yang dapat diverifikasi dengan menggunakan fungsi str(). Kode di bawah ini menyisipkan detail seperti id siswa, nama, nama belakang. 'INSERT INTO students (id, name, lastname) VALUES (:id, :name, :lastname)' Dimungkinkan untuk memasukkan nilai dalam bidang tertentu dengan metode values() untuk memasukkan objek. Kode untuk hal yang sama diberikan di bawah ini >>> ins = users . insert () . values ( name = 'Karan' ) >>> str ( ins ) 'INSERT INTO users (name) VALUES (:name)' SQL yang bergema di konsol Python tidak menunjukkan nilai sebenarnya ('Karan' dalam kasus ini). Sebagai gantinya, SQLALchemy menghasilkan parameter bind yang terlihat dalam bentuk pernyataan yang dikompilasi. ins . compile () . params { 'name' : 'Karan' } Demikian pula, metode seperti update(), delete() dan select() masing-masing membuat ekspresi UPDATE, DELETE dan SELECT. Kita akan belajar tentang mereka di bab-bab selanjutnya.","title":"SQL Expression"}]}